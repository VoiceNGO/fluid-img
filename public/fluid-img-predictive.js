var V=class extends Image{#e;constructor(e={}){super(),this.crossOrigin="Anonymous",this.#e=!!e.rotate}get width(){let e=this.#e?super.height:super.width;return e-e%2}get height(){return this.#e?super.width:super.height}},x=class{#e;#t;#r;#n;#a;constructor(e,t){this.#e=e,this.#n=t.rotate,this.#a=t.profiler,this.#t=this.#i(),this.#r=this.#t.then(r=>this.#s(r))}#i(){return new Promise((e,t)=>{let r=this.#e,n=new V({rotate:this.#n});n.onload=()=>e(n),n.onerror=()=>t(`Failed to load image: ${r}`),n.onabort=()=>t(`Image loading aborted: ${r}`),n.src=r})}#s(e){let t=this.#a;return new Promise(r=>{t?.start("loadImageData");let i=new OffscreenCanvas(e.width,e.height).getContext("2d");this.#n&&(i.translate(e.width,0),i.rotate(Math.PI/2)),i.drawImage(e,0,0);let o=i.getImageData(0,0,e.width,e.height);t?.end("loadImageData"),r(o)})}get src(){return this.#e}get image(){return this.#t}get imageData(){return this.#r}};var M="fluid-img";function E(p,e,t=1){let r=p.length-e.length*t,n=p.constructor,i=new n(r),o=0,a=0,g=-1;for(let m of e){if(g===m)throw new Error("[deleteArrayIndices]: Duplicate index detected");if(g>m)throw new Error("[deleteArrayIndices]: Indices are not sorted");let h=m-a;h>0&&(i.set(p.subarray(a,m),o),o+=h),a=m+t,g=m}return a<p.length&&i.set(p.subarray(a),o),i}function R(p,e,t=!1){let{data:r,width:n,height:i}=p,o=e?new Array(i):new Uint8Array(n*i);for(let a=0;a<i;a++){let g=a*n,m=e?o[a]=new Uint8Array(n):o;for(let h=0;h<n;h++){let s=(g+h)*4,y=r[s],c=r[s+1],d=r[s+2],l=r[s+3],u;t?u=(y+c+d)/3*l/255:u=(.299*y+.587*c+.114*d)*l/255,m[e?h:g+h]=u}}return o}var T=class{#e;#t;#r;#n;#a;#i;constructor(e){this.#t=e.imageData.width,this.#r=e.imageData.height,this.#e=new Array(this.#r),this.#a=new Array(this.#r),this.#i=e.maskData,this.#n=R(e.imageData,!0),this.#h(),this.#e=this.#o()}#s(e,t){if(!this.#i)return 255;let r=this.#a[e][t];return this.#i[r]}#h(){for(let e=0;e<this.#r;e++){this.#a[e]=new Uint32Array(this.#t);for(let t=0;t<this.#t;t++)this.#a[e][t]=e*this.#t+t}}#o(e=this.#t,t=this.#r){let r=new Array(t);for(let n=0;n<t;n++){r[n]=new Uint16Array(e);let i=Math.max(0,n-1),o=Math.min(t-1,n+1),a=this.#n[i],g=this.#n[n],m=this.#n[o];for(let h=0;h<e;h++){let s=Math.max(0,h-1),y=Math.min(e-1,h+1),c=-a[s]+a[y]+-g[s]*2+g[y]*2+-m[s]+m[y],d=-a[s]+-a[h]*2+-a[y]+m[s]+m[h]*2+m[y],l=(c<0?-c:c)+(d<0?-d:d),u=this.#s(n,h);r[n][h]=l*(u/255)}}return r}get width(){return this.#t}get height(){return this.#r}get energyMap(){return this.#e}get originalIndices(){return this.#a}removeSeam(e){for(let r=0;r<this.#r;r++){let n=e[r];this.#e[r]=E(this.#e[r],[n]),this.#a[r]=E(this.#a[r],[n])}this.#t--;let t=(r,n)=>r<n?r:r+1;for(let r=0;r<this.#r;r++){let n=e[r],i=Math.max(0,r-1),o=Math.min(this.#r-1,r+1),a=this.#n[i],g=this.#n[r],m=this.#n[o],h=[];n>0&&h.push(n-1),n<this.#t&&h.push(n);for(let s of h){let y=Math.max(0,t(s-1,n)),c=Math.min(this.#n[0].length-1,t(s+1,n)),d=t(s,n),l=-a[y]+a[c]+-g[y]*2+g[c]*2+-m[y]+m[c],u=-a[y]+-a[d]*2+-a[c]+m[y]+m[d]*2+m[c],b=(l<0?-l:l)+(u<0?-u:u),f=this.#s(r,s);this.#e[r][s]=b+f}}}removeSeams(e){if(e.length===0)return;let t=e.length;for(let r=0;r<this.#r;r++){let n=e.map(i=>i[r]).sort((i,o)=>i-o);this.#e[r]=E(this.#e[r],n),this.#n[r]=E(this.#n[r],n),this.#a[r]=E(this.#a[r],n)}this.#t-=t,this.#e=this.#o()}getEnergyMapAsImageData(e=this.#t,t=this.#r){let r=this.#o(e,t),n=1/0,i=0;for(let m=0;m<t;m++)for(let h=0;h<e;h++){let s=r[m][h];s<n&&(n=s),s>i&&(i=s)}let o=i-n,a=new ImageData(e,t),g=a.data;for(let m=0;m<t;m++)for(let h=0;h<e;h++){let s=(m*e+h)*4,y=r[m][h],c=o>0?Math.round((y-n)/o*255):0;g[s]=c,g[s+1]=c,g[s+2]=c,g[s+3]=255}return a}};j("sobel",T);var Y=new Map;function j(p,e){Promise.resolve().then(()=>{Y.set(p,e)})}function Q(p){let e=p.algorithm??"sobel",t=Y.get(e);if(!t)throw new Error(`[${M}] Energy map algorithm '${e}' is not registered or included in the build.`);return new t(p)}var C=class{impl;constructor(e){this.impl=Q(e)}get width(){return this.impl.width}get height(){return this.impl.height}get energyMap(){return this.impl.energyMap}get originalIndices(){return this.impl.originalIndices}removeSeam(e){return this.impl.removeSeam(e)}removeSeams(e){return this.impl.removeSeams(e)}getEnergyMapAsImageData(e,t){return this.impl.getEnergyMapAsImageData(e,t)}};var I=class{imageLoader;maskLoader;energyMapPromise;seamGrid=new Uint16Array;generatedSeams=0;constructor(e){this.imageLoader=e.imageLoader,this.maskLoader=e.maskLoader,this.energyMapPromise=this.createEnergyMap()}async getImageData(){return this.imageLoader.imageData}async getImage(){return this.imageLoader.image}async createEnergyMap(){let e=await this.imageLoader.imageData,t=await this.getMaskData();return this.seamGrid=new Uint16Array(e.width*e.height).fill(65535),new C({imageData:e,maskData:t})}async getMaskData(){if(!this.maskLoader)return;let e=await this.maskLoader.imageData;return R(e,!1)}async generateSeamGrid(e){let{width:t}=await this.imageLoader.image;if(t<e)throw new Error(`Cannot generate ${e} seams for image with width ${t}`);for(;this.generatedSeams<e;)await this.generateSeamBatch();return this.seamGrid}};var ae={constrainTo16Bit:!1,constrainToDiagonals:!1,accumulateUp:!1},U=class{#e;#t;#r;#n;constructor(e){this.#e={...ae,...e},this.#r=e.energyMap.width,this.#n=e.energyMap.height,this.#t=this.computeMinimalEnergyMap()}computeMinimalEnergyMap(){let{energyMap:e,constrainTo16Bit:t,constrainToDiagonals:r,accumulateUp:n}=this.#e,{width:i,height:o}=e,a=new Array(o),g=n?o-1:0,m=n?-1:o,h=n?-1:1,s=t?o/256:1,y=t?Math.ceil(Math.log2(s)):0,c=e.energyMap;a[g]=new(t?Uint16Array:Uint32Array)(c[g]);for(let d=g+h;d!==m;d+=h){a[d]=new(t?Uint16Array:Uint32Array)(i);for(let l=0;l<i;l++){let u=c[d][l],b=a[d-h][l-1]??1/0,f=a[d-h][l+1]??1/0,D=r?1/0:a[d-h][l],w=Math.min(b,f,D);a[d][l]=u+w>>y}}return a}removeSeams(e){if(e.length!==0){for(let t=0;t<this.#n;t++){let r=e.map(n=>n[t]).sort((n,i)=>n-i);this.#t[t]=E(this.#t[t],r)}this.#r-=e.length}}get minimalEnergyMap(){return this.#t}};var k=class{timing;values;head;tail;windowSize;time;constructor(e,t=1e3,r=Uint16Array){this.windowSize=e,this.timing=new Uint16Array(t),this.values=new r(t),this.tail=0,this.head=0,this.time=0}addAndGetMax(e){for(this.time++;this.timing[this.tail]<=this.time-this.windowSize&&this.head>this.tail;)this.tail++;for(;this.values[this.head-1]<=e&&this.head>this.tail;)this.head--;return this.head>=this.timing.length&&(this.timing.set(this.timing.subarray(this.tail,this.head),0),this.values.set(this.values.subarray(this.tail,this.head),0),this.head=this.head-this.tail,this.tail=0),this.values[this.head]=e,this.timing[this.head]=this.time,this.head++,this.values[this.tail]}};var ie={batchPercentage:.1,minBatchSize:10},F=class extends I{options;constructor(e){super(e),this.options={...ie,...e}}setBatchPercentage(e){this.options.batchPercentage=e}async generateSeamBatch(){let e=await this.energyMapPromise,t=e.originalIndices,r=e.width,n=e.height,o=new U({energyMap:e,accumulateUp:!0}).minimalEnergyMap,a=[],g=e.energyMap;for(let c=0;c<r;c++){let d=g[0][c];a.push({path:new Uint16Array(n),energy:d,slidingWindowMaximum:new k(1)}),a[c].path[0]=c}let m=a;for(let c=1;c<n;c++){let d=[];for(let l=0;l<r;l++){let u=m[l];if(l===r-1){u.path[c]=l,u.energy+=u.slidingWindowMaximum.addAndGetMax(g[c][l]),d[l]=u;continue}let b=m[l+1],f=u.energy<b.energy,D=o[c][l]<o[c][l+1];f===D?(u.path[c]=l,u.energy+=u.slidingWindowMaximum.addAndGetMax(g[c][l]),d[l]=u):(u.path[c]=l+1,u.energy+=u.slidingWindowMaximum.addAndGetMax(g[c][l+1]),d[l+1]=u,b.path[c]=l,b.energy+=b.slidingWindowMaximum.addAndGetMax(g[c][l]),d[l]=b,l++)}m=d}a.sort((c,d)=>c.energy-d.energy);let h=Math.max(Math.ceil(r*this.options.batchPercentage)>>1<<1,Math.min(this.options.minBatchSize,r)),s=a.slice(0,h),y=this.generatedSeams;for(let c=0;c<s.length;c++)s[c].path.forEach((l,u)=>{let b=t[u][l];if(this.seamGrid[b]!==65535)throw new Error("Seam overlap detected");this.seamGrid[b]=y}),y++;e.removeSeams(s.map(c=>c.path)),this.generatedSeams+=s.length}};X("predictive",F);var K=new Map;function X(p,e){Promise.resolve().then(()=>{K.set(p,e)})}function Z(p){let e=p.generator??"random",t=K.get(e);if(!t)throw new Error(`[${M}] Generator '${e}' is not registered or included in the build.`);return new t(p)}var L=class{#e;#t=new Map;#r=[];constructor(e){this.#e=e}start(e,t=0){this.#t.set(e,{startTime:performance.now(),minLoggingTime:t,totalNestedTime:0}),this.#r.push(e)}end(e){let{startTime:t,minLoggingTime:r,totalNestedTime:n}=this.#t.get(e),i=performance.now()-t;if(i<r)return;let o=this.#r.length;if(o>1){let a=this.#r[o-2],g=this.#t.get(a);g.totalNestedTime+=i}n>0?this.#e(`${e}: ${(i-n).toFixed(2)}ms (${i.toFixed(2)}ms)`):this.#e(`${e}: ${(i-n).toFixed(2)}ms`),this.#r.pop(),this.#t.delete(e)}};function _(p){return function(...t){if(!this.hasFailed)try{let r=p.apply(this,t);return r&&typeof r.catch=="function"?r.catch(n=>{this.handleFailure(n)}):r}catch(r){this.handleFailure(r)}}}function A(p){return p.replace(/([A-Z])/g,"-$1").toLowerCase()}var J=p=>({getConstrainedNumber:(n,i,o=0,a=1)=>{let g=String(n),m=Number(p[A(g)]??i);if(m<o||m>a)throw new Error(`[${M}] \`${g}\` must be between ${o} and ${a}.`);return m},getBoolean:(n,i)=>{let o=String(n),a=p[A(o)];return a===null?!1:a!==void 0?!0:i},getEnumValue:(n,i,o)=>{let a=String(n),g=p[A(a)];return g==null?o:Object.values(i).includes(g)?g:(console.warn(`[${M}] Invalid value for ${a}: "${g}". Defaulting to "${o}".`),o)}});var S={Horizontal:"horizontal",Vertical:"vertical",Auto:"auto",Dual:"dual"};var z=class{canvas;ctx;height=0;width=0;options;internalHorizontalGenerator;internalVerticalGenerator;currentGenerator;isVertical;redrawQueued=!1;profiler;hasFailed=!1;parentNode;src;mask;cachedEnergyMapImageData=null;setOptions=_(this._setOptions).bind(this);redraw=_(this._redraw).bind(this);constructor(e){let{parentNode:t,src:r,mask:n,...i}=e;this.parentNode=t,this.src=r,this.mask=n;try{this.options=this.validateAndApplyDefaults(i),this.profiler=new L(this.options.logger),this.initializeCanvas(t)}catch(o){this.handleFailure(o)}}destroy(){this.canvas.remove()}get horizontalGenerator(){if(!this.internalHorizontalGenerator){let e=new x(this.src,{rotate:!1,profiler:this.profiler}),t=this.mask?new x(this.mask,{rotate:!1}):void 0;this.internalHorizontalGenerator=this.createGenerator({imageLoader:e,maskLoader:t})}return this.internalHorizontalGenerator}get verticalGenerator(){if(!this.internalVerticalGenerator){let e=new x(this.src,{rotate:!0,profiler:this.profiler}),t=this.mask?new x(this.mask,{rotate:!0}):void 0;this.internalVerticalGenerator=this.createGenerator({imageLoader:e,maskLoader:t})}return this.internalVerticalGenerator}determineCurrentGenerator(){return this.isVertical?this.verticalGenerator:this.horizontalGenerator}createGenerator(e){let t={...this.options,imageLoader:e.imageLoader,maskLoader:e.maskLoader};return Z(t)}validateAndApplyDefaults(e){let{getBoolean:t,getConstrainedNumber:r,getEnumValue:n}=J(e);return{...e,carvingPriority:r("carvingPriority",1),maxCarveUpSeamPercentage:r("maxCarveUpSeamPercentage",.6),maxCarveUpScale:r("maxCarveUpScale",10,1,10),maxCarveDownScale:r("maxCarveDownScale",1),scalingAxis:n("scalingAxis",S,S.Horizontal),logger:e.logger??(()=>{}),showEnergyMap:t("showEnergyMap",!1),demoMode:t("demoMode",!1)}}calculateDimensions(e){let{width:t,height:r}=this.options;if(t===void 0||r===void 0){let n=e.getBoundingClientRect();t=t??n.width,r=r??n.height}return{width:t,height:r}}initializeCanvas(e){let{width:t,height:r}=this.calculateDimensions(e);this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d"),this.canvas.width=this.width=t,this.canvas.height=this.height=r,this.canvas.style.display="block",e.appendChild(this.canvas),this.queueRedraw()}setSize(e,t){this.width=e,this.height=t,this.queueRedraw()}setWidth(e){this.width=e,this.queueRedraw()}setHeight(e){this.height=e,this.queueRedraw()}_setOptions(e){let t=this.options.showEnergyMap;this.options=this.validateAndApplyDefaults({...this.options,...e}),this.options.showEnergyMap!==t&&(this.cachedEnergyMapImageData=null),this.queueRedraw()}queueRedraw(){this.redrawQueued||(this.redrawQueued=!0,Promise.resolve().then(async()=>{await this.redraw(),this.redrawQueued=!1}))}determineCarvingParameters(e){let{carvingPriority:t,maxCarveUpSeamPercentage:r,maxCarveUpScale:n,maxCarveDownScale:i}=this.options,{width:o,height:a}=e,{isVertical:g,width:m,height:h}=this,s=g?h:m,y=g?m:h,c=s/y,d=Math.round(a*c),l=o-d;if(l===0)return{availableSeams:0,interpolationPixels:0,carveDown:!1};let u=Math.abs(l)*t,b=l>0?i:r,f=o*b,D=l>0?1:-1,w=l>0,v=Math.floor(Math.min(u,f))*D;if(w)return{availableSeams:v,interpolationPixels:0,carveDown:w};{let O=Math.round(a/y*s)-o,P=Math.floor(o*n)-o,$=Math.max(0,Math.min(O,P));return{availableSeams:-v,interpolationPixels:$,carveDown:w}}}async determineOrientation(){if(this.options.scalingAxis===S.Horizontal)return!1;if(this.options.scalingAxis===S.Vertical)return!0;let{width:e,height:t}=await this.horizontalGenerator.getImage(),r=e/t;return this.width/this.height>r}async refreshCachedArgs(){this.isVertical=await this.determineOrientation(),this.currentGenerator=this.determineCurrentGenerator()}async getEnergyMapImageData(){if(this.cachedEnergyMapImageData)return this.cachedEnergyMapImageData;let e=await this.currentGenerator.getImageData(),t=new C({imageData:e});return this.cachedEnergyMapImageData=t.getEnergyMapAsImageData(),this.cachedEnergyMapImageData}async getSourceImageData(){return this.options.showEnergyMap?await this.getEnergyMapImageData():await this.currentGenerator.getImageData()}async _redraw(){if(!this.width||!this.height)return;this.profiler.start("redraw"),await this.refreshCachedArgs();let e=await this.getSourceImageData(),{availableSeams:t,interpolationPixels:r,carveDown:n}=this.determineCarvingParameters(e),i;if(t===0)i=e;else{this.profiler.start("generateSeamGrid",1);let h=await this.currentGenerator.generateSeamGrid(Math.abs(t));this.profiler.end("generateSeamGrid"),n?i=this.filterPixels(e,h,t):i=this.interpolatePixels(e,h,t,r)}this.canvas.width=i.width,this.canvas.height=i.height,this.ctx.putImageData(i,0,0);let o=this.canvas.style,{isVertical:a,width:g,height:m}=this;o.transformOrigin="0 0",o.transform=a?"rotate(-90deg) translateX(-100%)":"",o.width=`${a?m:g}px`,o.height=`${a?g:m}px`,this.profiler.end("redraw")}interpolatePixels(e,t,r,n){let{width:i,height:o,data:a}=e,g=i+n,m=g*o*4,h=new Uint8ClampedArray(m),s=0,y=a.length/4,c=Math.floor(n/r),d=n%r,l=0;for(let u=0;u<y;u++){let b=t[u],f=u*4;if(b<r){let w=d>0&&b*d%r<d?c+1:c;if(l===0)for(let v=0;v<w;v++)h[s]=a[f],h[s+1]=a[f+1],h[s+2]=a[f+2],h[s+3]=a[f+3],s+=4;else{let v=(u-1)*4,B=a[v],O=a[v+1],N=a[v+2],P=a[v+3],q=a[f]-B,$=a[f+1]-O,ee=a[f+2]-N,te=a[f+3]-P,re=w+1;for(let W=0;W<w;W++){let G=(W+1)/re;h[s]=Math.round(B+q*G),h[s+1]=Math.round(O+$*G),h[s+2]=Math.round(N+ee*G),h[s+3]=Math.round(P+te*G),s+=4}}}h[s]=a[f],h[s+1]=a[f+1],h[s+2]=a[f+2],h[s+3]=a[f+3],s+=4,++l===i&&(l=0)}return s!==m&&console.error(`[${M}] Mismatch during interpolation. Wrote ${s} bytes but expected ${m}.`),new ImageData(h,g,o)}filterPixels(e,t,r){let{width:n,height:i,data:o}=e,a=n-r,g=a*i*4,m=new Uint8ClampedArray(g),h=o.length/4,s=0;for(let y=0;y<h;y++)if(t[y]>=r){let d=y*4;m[s]=o[d],m[s+1]=o[d+1],m[s+2]=o[d+2],m[s+3]=o[d+3],s+=4}return s!==g&&console.error(`[${M}] Mismatch in pixel buffer size. Expected ${g}, but got ${s}.`),new ImageData(m,a,i)}handleFailure(e){if(this.hasFailed)return;this.hasFailed=!0,console.error(`[${M}] A critical error occurred. Falling back to <img>.`,e),this.canvas?.remove();let t=document.createElement("img");t.src=this.src,t.style.width="100%",t.style.height="100%",t.style.display="block",this.parentNode.appendChild(t)}};var H=class p extends HTMLElement{renderer=null;resizeObserver=null;intersectionObserver=null;updateQueue=new Set;isIntersecting=!1;storedDimensions=null;options={};static destructiveProperties=new Set(["src","scaling-axis","mask","generator"]);constructor(){super()}static get observedAttributes(){return["src","mask","on-screen-threshold",...["generator","carvingPriority","maxCarveUpSeamPercentage","maxCarveUpScale","maxCarveDownScale","scalingAxis","showEnergyMap","mask"].map(A)]}connectedCallback(){this.setupResizeObserver(),this.setupIntersectionObserver()}disconnectedCallback(){this.renderer?.destroy(),this.renderer=null,this.resizeObserver?.disconnect(),this.resizeObserver=null,this.intersectionObserver?.disconnect(),this.intersectionObserver=null}attributeChangedCallback(e,t,r){t!==r&&(this.updateQueue.size||setTimeout(this.processUpdates),this.updateQueue.add(e))}processUpdates=()=>{let e=Array.from(this.updateQueue);if(this.updateQueue.clear(),e.some(r=>p.destructiveProperties.has(r))){this.renderer?.destroy(),this.renderer=null,this.initializeRenderer();return}if(e.includes("on-screen-threshold")&&this.setupIntersectionObserver(),!this.renderer)return;let t=e.reduce((r,n)=>{if(n!=="src"&&n!=="on-screen-threshold"){let i=this.getAttribute(n);r[n]=i}return r},{});this.renderer.setOptions(t)};dispatchLogEvent=e=>{let t=new CustomEvent("log",{detail:{message:e},bubbles:!0,composed:!0});this.dispatchEvent(t)};initializeRenderer(){if(this.renderer)return;let e=this.getOptions();this.renderer=new z({parentNode:this,logger:this.dispatchLogEvent,...e})}calculateDimensions(){let e=this.clientWidth??100,t=this.clientHeight??100;return{width:e,height:t}}getOptions(){let e={};for(let t of p.observedAttributes){let r=A(t);if(this.hasAttribute(r)){let n=this.getAttribute(r);e[t]={"":!0,true:!0,false:!1}[n+""]??n}}return e}setupResizeObserver(){this.parentElement&&(this.resizeObserver=new ResizeObserver(()=>{let e=this.calculateDimensions();this.storedDimensions=e,this.attemptSetSize()}),this.resizeObserver.observe(this))}setupIntersectionObserver(){this.intersectionObserver?.disconnect();let e=this.getAttribute("on-screen-threshold")||"50px";this.intersectionObserver=new IntersectionObserver(t=>{for(let r of t)this.isIntersecting=r.isIntersecting,this.isIntersecting&&this.attemptSetSize()},{rootMargin:`${e} ${e} ${e} ${e}`}),this.intersectionObserver.observe(this)}attemptSetSize(){!this.isIntersecting||!this.storedDimensions||(this.renderer?.setSize(this.storedDimensions.width,this.storedDimensions.height),this.storedDimensions=null)}get maxCarveUpScale(){return this.options["max-carve-up-scale"]}set maxCarveUpScale(e){this.options["max-carve-up-scale"]=e,this.renderer?.setOptions({maxCarveUpScale:e})}get scalingAxis(){return this.options["scaling-axis"]}set scalingAxis(e){this.options["scaling-axis"]=e,this.renderer?.setOptions({scalingAxis:e})}get showEnergyMap(){return this.options["show-energy-map"]}set showEnergyMap(e){this.options["show-energy-map"]=e,this.renderer?.setOptions({showEnergyMap:e})}get onScreenThreshold(){let e=this.getAttribute("on-screen-threshold")||"50px";return parseInt(e.replace("px",""),10)}};customElements.define("fluid-img",H);export{H as FluidImg};
//# sourceMappingURL=fluid-img-predictive.js.map
