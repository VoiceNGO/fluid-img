{
  "version": 3,
  "sources": ["../src/utils/image-loader/image-loader.ts", "../src/utils/deterministic-binary-rnd/deterministic-binary-rnd.ts", "../src/utils/delete-array-indicies/delete-array-indicies.ts", "../src/generator/grayscale/grayscale.ts", "../src/generator/sobel-energy-map/sobel-energy-map.ts", "../src/generator/dual-energy-map/dual-energy-map.ts", "../src/generator/boundary-aware-energy-map/boundary-aware-energy-map.ts", "../src/generator/energy-map/energy-map.ts", "../src/generator/base-generator/base-generator.ts", "../src/generator/random-generator/random-generator.ts", "../src/generator/generator/generator.ts", "../src/utils/profiler/profiler.ts", "../src/utils/error-boundary/error-boundary.ts", "../src/utils/to-kebab-case/to-kebab-case.ts", "../package.json", "../src/utils/option-helpers/option-helpers.ts", "../src/utils/enums/enums.ts", "../src/renderer/renderer/renderer.ts", "../src/renderer/web-component/web-component.ts"],
  "sourcesContent": ["import { Profiler } from '../../utils/profiler/profiler';\n\nclass EvenWidthImage extends Image {\n  #rotate: boolean;\n\n  constructor(options: { rotate?: boolean } = {}) {\n    super();\n    this.crossOrigin = `Anonymous`;\n    this.#rotate = !!options.rotate;\n  }\n\n  override get width(): number {\n    const originalWidth = this.#rotate ? super.height : super.width;\n    return originalWidth - (originalWidth % 2);\n  }\n\n  override get height(): number {\n    return this.#rotate ? super.width : super.height;\n  }\n}\n\nexport class ImageLoader {\n  #src: string;\n  #imgPromise: Promise<HTMLImageElement>;\n  #imageDataPromise: Promise<ImageData>;\n  #rotate: boolean;\n  #profiler?: Profiler;\n\n  constructor(src: string, options: { rotate: boolean; profiler?: Profiler }) {\n    this.#src = src;\n    this.#rotate = options.rotate;\n    this.#profiler = options.profiler;\n    this.#imgPromise = this.#loadImage();\n    this.#imageDataPromise = this.#imgPromise.then((img) => this.#loadImageData(img));\n  }\n\n  #loadImage(): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n      const src = this.#src;\n      const img = new EvenWidthImage({ rotate: this.#rotate });\n      img.onload = () => resolve(img);\n      img.onerror = () => reject(`Failed to load image: ${src}`);\n      img.onabort = () => reject(`Image loading aborted: ${src}`);\n      img.src = src;\n    });\n  }\n\n  #loadImageData(image: HTMLImageElement): Promise<ImageData> {\n    const profiler = this.#profiler;\n\n    return new Promise((resolve) => {\n      profiler?.start('loadImageData');\n      const canvas = new OffscreenCanvas(image.width, image.height);\n      const context = canvas.getContext('2d')!;\n\n      if (this.#rotate) {\n        context.translate(image.width, 0);\n        context.rotate(Math.PI / 2);\n      }\n\n      context.drawImage(image, 0, 0);\n\n      const imageData = context.getImageData(0, 0, image.width, image.height);\n\n      profiler?.end('loadImageData');\n\n      resolve(imageData);\n    });\n  }\n\n  get src(): string {\n    return this.#src;\n  }\n\n  get image(): Promise<HTMLImageElement> {\n    return this.#imgPromise;\n  }\n\n  get imageData(): Promise<ImageData> {\n    return this.#imageDataPromise;\n  }\n}\n", "export const deterministicBinaryRnd =\n  (seed1: number) =>\n  (seed2: number): number => {\n    let h = seed1 ^ seed2;\n    h ^= h >>> 16;\n    h *= 0x85ebca6b;\n    h ^= h >>> 13;\n    h *= 0xc2b2ae35;\n    h ^= h >>> 16;\n    return h & 1;\n  };\n", "import type { TypedArray, Constructor } from 'type-fest';\n\nexport function deleteArrayIndices<T extends TypedArray>(\n  array: T,\n  uniqueSortedIndicesToRemove: number[],\n  elementsPerRemoval: number = 1\n): T {\n  const newSize = array.length - uniqueSortedIndicesToRemove.length * elementsPerRemoval;\n  const ArrayConstructor = array.constructor as Constructor<T>;\n  const result = new ArrayConstructor(newSize) as T;\n\n  let resultOffset = 0;\n  let sourceStart = 0;\n  let lastIndex = -1;\n\n  for (const deleteIndex of uniqueSortedIndicesToRemove) {\n    if (lastIndex === deleteIndex) {\n      throw new Error('[deleteArrayIndices]: Duplicate index detected');\n    }\n    if (lastIndex > deleteIndex) {\n      throw new Error('[deleteArrayIndices]: Indices are not sorted');\n    }\n\n    const chunkSize = deleteIndex - sourceStart;\n\n    if (chunkSize > 0) {\n      (result as any).set(array.subarray(sourceStart, deleteIndex), resultOffset);\n      resultOffset += chunkSize;\n    }\n\n    sourceStart = deleteIndex + elementsPerRemoval;\n    lastIndex = deleteIndex;\n  }\n\n  if (sourceStart < array.length) {\n    (result as any).set(array.subarray(sourceStart), resultOffset);\n  }\n\n  return result;\n}\n", "import { GrayscalePixelArray } from '../../utils/types/types';\n\nexport function getGrayscaleImageData<AsRows extends boolean>(\n  imageData: ImageData,\n  asRows: AsRows,\n  useLinearApproximation = false\n): AsRows extends true ? Uint8Array[] : GrayscalePixelArray {\n  const { data, width, height } = imageData;\n  const grayscaleData = asRows ? new Array(height) : new Uint8Array(width * height);\n\n  for (let y = 0; y < height; y++) {\n    const rowOffset = y * width;\n    const currentArray = asRows ? (grayscaleData[y] = new Uint8Array(width)) : grayscaleData;\n\n    for (let x = 0; x < width; x++) {\n      const ix = (rowOffset + x) * 4;\n      const r = data[ix];\n      const g = data[ix + 1];\n      const b = data[ix + 2];\n      const a = data[ix + 3];\n\n      let gray;\n      if (useLinearApproximation) {\n        gray = (((r! + g! + b!) / 3) * a!) / 255;\n      } else {\n        gray = ((0.299 * r! + 0.587 * g! + 0.114 * b!) * a!) / 255;\n      }\n\n      currentArray[asRows ? x : rowOffset + x] = gray;\n    }\n  }\n\n  return grayscaleData as any;\n}\n", "// TODO: Test Sobel energy calculation using sqrt(Gx^2 + Gy^2) and adjust normalization for comparison.\n// Current method uses abs(Gx) + abs(Gy).\nimport type { Tagged } from 'type-fest';\nimport { deleteArrayIndices } from '../../utils/delete-array-indicies/delete-array-indicies';\nimport { getGrayscaleImageData } from '../grayscale/grayscale';\nimport { GrayscalePixelArray } from '../../utils/types/types';\n\ntype EnergyMapData = Tagged<Uint16Array, 'energyMapData'>;\ntype EnergyMapIndices = Tagged<Uint32Array, 'energyMapIndices'>;\n\nexport class SobelEnergyMap {\n  #data: EnergyMapData[];\n  #width: number;\n  #height: number;\n  #grayscaleMap: Uint8Array[];\n  #originalIndices: EnergyMapIndices[];\n  #maskData?: GrayscalePixelArray;\n\n  constructor(imageData: ImageData, maskData?: GrayscalePixelArray) {\n    this.#width = imageData.width;\n    this.#height = imageData.height;\n    this.#data = new Array(this.#height);\n    this.#originalIndices = new Array(this.#height);\n    this.#maskData = maskData;\n\n    this.#grayscaleMap = getGrayscaleImageData(imageData, true);\n    this.#fillOriginalIndices();\n    this.#data = this.#computeFullEnergyMap();\n  }\n\n  #getMaskEnergy(y: number, x: number): number {\n    if (!this.#maskData) {\n      return 255;\n    }\n    const originalIndex = this.#originalIndices[y]![x]!;\n    return this.#maskData[originalIndex]!;\n  }\n\n  #fillOriginalIndices(): void {\n    for (let y = 0; y < this.#height; y++) {\n      this.#originalIndices[y] = new Uint32Array(this.#width) as EnergyMapIndices;\n      for (let x = 0; x < this.#width; x++) {\n        this.#originalIndices[y]![x] = y * this.#width + x;\n      }\n    }\n  }\n\n  #computeFullEnergyMap(\n    width: number = this.#width,\n    height: number = this.#height\n  ): EnergyMapData[] {\n    const energyMapData: EnergyMapData[] = new Array(height);\n\n    for (let y = 0; y < height; y++) {\n      energyMapData[y] = new Uint16Array(width) as EnergyMapData;\n\n      const y1 = Math.max(0, y - 1);\n      const y3 = Math.min(height - 1, y + 1);\n      const prevRow = this.#grayscaleMap[y1]!;\n      const currentRow = this.#grayscaleMap[y]!;\n      const nextRow = this.#grayscaleMap[y3]!;\n\n      for (let x = 0; x < width; x++) {\n        const x1 = Math.max(0, x - 1);\n        const x3 = Math.min(width - 1, x + 1);\n\n        const gx =\n          -prevRow[x1]! +\n          prevRow[x3]! +\n          -currentRow[x1]! * 2 +\n          currentRow[x3]! * 2 +\n          -nextRow[x1]! +\n          nextRow[x3]!;\n\n        const gy =\n          -prevRow[x1]! +\n          -prevRow[x]! * 2 +\n          -prevRow[x3]! +\n          nextRow[x1]! +\n          nextRow[x]! * 2 +\n          nextRow[x3]!;\n\n        const sobelEnergy = (gx < 0 ? -gx : gx) + (gy < 0 ? -gy : gy);\n        const maskEnergy = this.#getMaskEnergy(y, x);\n        energyMapData[y]![x] = sobelEnergy * (maskEnergy / 255);\n      }\n    }\n\n    return energyMapData;\n  }\n\n  get width(): number {\n    return this.#width;\n  }\n\n  get height(): number {\n    return this.#height;\n  }\n\n  get energyMap(): readonly EnergyMapData[] {\n    return this.#data;\n  }\n\n  get originalIndices(): readonly EnergyMapIndices[] {\n    return this.#originalIndices;\n  }\n\n  removeSeam(xIndices: Uint16Array): void {\n    for (let y = 0; y < this.#height; y++) {\n      const xToRemove = xIndices[y]!;\n      this.#data[y] = deleteArrayIndices(this.#data[y]!, [xToRemove]);\n      this.#originalIndices[y] = deleteArrayIndices(this.#originalIndices[y]!, [xToRemove]);\n    }\n    this.#width--;\n\n    const g = (colInNewCoord: number, removedOriginalIndex: number) =>\n      colInNewCoord < removedOriginalIndex ? colInNewCoord : colInNewCoord + 1;\n\n    for (let y = 0; y < this.#height; y++) {\n      const removedColOrigIdx = xIndices[y]!;\n\n      // Cache row references with clamping\n      const y1 = Math.max(0, y - 1);\n      const y3 = Math.min(this.#height - 1, y + 1);\n      const prevRow = this.#grayscaleMap[y1]!;\n      const currentRow = this.#grayscaleMap[y]!;\n      const nextRow = this.#grayscaleMap[y3]!;\n\n      const columnsInNewDataToUpdate: number[] = [];\n      if (removedColOrigIdx > 0) {\n        columnsInNewDataToUpdate.push(removedColOrigIdx - 1);\n      }\n      if (removedColOrigIdx < this.#width) {\n        columnsInNewDataToUpdate.push(removedColOrigIdx);\n      }\n\n      for (const xCurrent of columnsInNewDataToUpdate) {\n        const x1 = Math.max(0, g(xCurrent - 1, removedColOrigIdx));\n        const x3 = Math.min(this.#grayscaleMap[0]!.length - 1, g(xCurrent + 1, removedColOrigIdx));\n        const xCenter = g(xCurrent, removedColOrigIdx);\n\n        const gx =\n          -prevRow[x1]! +\n          prevRow[x3]! +\n          -currentRow[x1]! * 2 +\n          currentRow[x3]! * 2 +\n          -nextRow[x1]! +\n          nextRow[x3]!;\n\n        const gy =\n          -prevRow[x1]! +\n          -prevRow[xCenter]! * 2 +\n          -prevRow[x3]! +\n          nextRow[x1]! +\n          nextRow[xCenter]! * 2 +\n          nextRow[x3]!;\n\n        const sobelEnergy = (gx < 0 ? -gx : gx) + (gy < 0 ? -gy : gy);\n        const maskEnergy = this.#getMaskEnergy(y, xCurrent);\n        this.#data[y]![xCurrent] = sobelEnergy + maskEnergy;\n      }\n    }\n  }\n\n  removeSeams(seams: Uint16Array[]): void {\n    if (seams.length === 0) {\n      return;\n    }\n\n    const numSeamsToRemove = seams.length;\n\n    for (let y = 0; y < this.#height; y++) {\n      const indicesToRemoveForRow: number[] = seams\n        .map((seamPath) => seamPath[y]!)\n        .sort((a, b) => a - b);\n\n      this.#data[y] = deleteArrayIndices(this.#data[y]!, indicesToRemoveForRow);\n      this.#grayscaleMap[y] = deleteArrayIndices(this.#grayscaleMap[y]!, indicesToRemoveForRow);\n      this.#originalIndices[y] = deleteArrayIndices(\n        this.#originalIndices[y]!,\n        indicesToRemoveForRow\n      );\n    }\n\n    this.#width -= numSeamsToRemove;\n\n    this.#data = this.#computeFullEnergyMap();\n  }\n\n  getEnergyMapAsImageData(width: number = this.#width, height: number = this.#height): ImageData {\n    const energyMapData = this.#computeFullEnergyMap(width, height);\n\n    // Find min and max energy values for normalization\n    let minEnergy = Infinity;\n    let maxEnergy = 0;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const energy = energyMapData[y]![x]!;\n        if (energy < minEnergy) minEnergy = energy;\n        if (energy > maxEnergy) maxEnergy = energy;\n      }\n    }\n\n    const energyRange = maxEnergy - minEnergy;\n    const imageData = new ImageData(width, height);\n    const data = imageData.data;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const index = (y * width + x) * 4;\n        const energy = energyMapData[y]![x]!;\n\n        // Normalize energy to 0-255 range\n        const normalizedEnergy =\n          energyRange > 0 ? Math.round(((energy - minEnergy) / energyRange) * 255) : 0;\n\n        // Set RGB channels to the same value for grayscale\n        data[index] = normalizedEnergy; // R\n        data[index + 1] = normalizedEnergy; // G\n        data[index + 2] = normalizedEnergy; // B\n        data[index + 3] = 255; // A (100% alpha)\n      }\n    }\n\n    return imageData;\n  }\n}\n", "import type { Tagged } from 'type-fest';\nimport { deleteArrayIndices } from '../../utils/delete-array-indicies/delete-array-indicies';\nimport { GrayscalePixelArray } from '../../utils/types/types';\n\nfunction getPixelIndex(x: number, y: number, width: number): number {\n  return (y * width + x) * 4;\n}\n\nfunction getGrayscale(x: number, y: number, width: number, data: Uint8ClampedArray): number {\n  if (x < 0 || x >= width || y < 0 || y >= Math.floor(data.length / (width * 4))) {\n    return 0;\n  }\n  const i = getPixelIndex(x, y, width);\n\n  return 0.299 * data[i]! + 0.587 * data[i + 1]! + (0.114 * data[i + 2]! * data[i + 3]!) / 255;\n}\n\nfunction getColorDistance(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  width: number,\n  data: Uint8ClampedArray\n): number {\n  if (\n    x1 < 0 ||\n    x1 >= width ||\n    y1 < 0 ||\n    y1 >= Math.floor(data.length / (width * 4)) ||\n    x2 < 0 ||\n    x2 >= width ||\n    y2 < 0 ||\n    y2 >= Math.floor(data.length / (width * 4))\n  ) {\n    return 0;\n  }\n\n  const i1 = getPixelIndex(x1, y1, width);\n  const i2 = getPixelIndex(x2, y2, width);\n\n  const dr = data[i1]! - data[i2]!;\n  const dg = data[i1 + 1]! - data[i2 + 1]!;\n  const db = data[i1 + 2]! - data[i2 + 2]!;\n\n  return Math.sqrt(dr * dr + dg * dg + db * db);\n}\n\ntype EnergyMapData = Tagged<Uint16Array, 'energyMapData'>;\ntype EnergyMapIndices = Tagged<Uint32Array, 'energyMapIndices'>;\n\nexport class DualEnergyMap {\n  #data: EnergyMapData[];\n  #width: number;\n  #height: number;\n  #grayscaleMap: Uint8Array[];\n  #originalIndices: EnergyMapIndices[];\n  #imageData: ImageData;\n  #forwardEnergyWeight: number;\n\n  constructor(\n    imageData: ImageData,\n    forwardEnergyWeight: number = 1.0,\n    maskData?: GrayscalePixelArray\n  ) {\n    this.#width = imageData.width;\n    this.#height = imageData.height;\n    this.#imageData = imageData;\n    this.#forwardEnergyWeight = forwardEnergyWeight;\n    this.#data = new Array(this.#height);\n    this.#grayscaleMap = new Array(this.#height);\n    this.#originalIndices = new Array(this.#height);\n\n    this.#fillOriginalIndices();\n    this.#computeGrayscaleMap(imageData);\n    this.#data = this.#computeFullEnergyMap();\n  }\n\n  #fillOriginalIndices(): void {\n    for (let y = 0; y < this.#height; y++) {\n      this.#originalIndices[y] = new Uint32Array(this.#width) as EnergyMapIndices;\n      for (let x = 0; x < this.#width; x++) {\n        this.#originalIndices[y]![x] = y * this.#width + x;\n      }\n    }\n  }\n\n  #computeGrayscaleMap(imageData: ImageData): void {\n    for (let y = 0; y < this.#height; y++) {\n      this.#grayscaleMap[y] = new Uint8Array(this.#width);\n      for (let x = 0; x < this.#width; x++) {\n        this.#grayscaleMap[y]![x] = getGrayscale(x, y, this.#width, imageData.data);\n      }\n    }\n  }\n\n  #computeBackwardEnergy(x: number, y: number): number {\n    // Sobel operator for backward energy (gradient at current pixel)\n    const y1 = Math.max(0, y - 1);\n    const y3 = Math.min(this.#height - 1, y + 1);\n    const x1 = Math.max(0, x - 1);\n    const x3 = Math.min(this.#width - 1, x + 1);\n\n    const prevRow = this.#grayscaleMap[y1]!;\n    const currentRow = this.#grayscaleMap[y]!;\n    const nextRow = this.#grayscaleMap[y3]!;\n\n    const gx =\n      -prevRow[x1]! +\n      prevRow[x3]! +\n      -currentRow[x1]! * 2 +\n      currentRow[x3]! * 2 +\n      -nextRow[x1]! +\n      nextRow[x3]!;\n\n    const gy =\n      -prevRow[x1]! +\n      -prevRow[x]! * 2 +\n      -prevRow[x3]! +\n      nextRow[x1]! +\n      nextRow[x]! * 2 +\n      nextRow[x3]!;\n\n    return (gx < 0 ? -gx : gx) + (gy < 0 ? -gy : gy);\n  }\n\n  #computeForwardEnergy(x: number, y: number): number {\n    // Forward energy: cost of connecting neighbors when this pixel is removed\n    const data = this.#imageData.data;\n\n    // Cost of connecting left and right neighbors\n    const leftX = x - 1;\n    const rightX = x + 1;\n    const horizontalCost = getColorDistance(leftX, y, rightX, y, this.#width, data);\n\n    // Cost of connecting top and bottom neighbors\n    const topY = y - 1;\n    const bottomY = y + 1;\n    const verticalCost = getColorDistance(x, topY, x, bottomY, this.#width, data);\n\n    // Additional costs for diagonal connections that may be created\n    let diagonalCost = 0;\n    if (leftX >= 0 && topY >= 0) {\n      diagonalCost += getColorDistance(leftX, topY, rightX, y, this.#width, data);\n    }\n    if (rightX < this.#width && bottomY < this.#height) {\n      diagonalCost += getColorDistance(rightX, bottomY, leftX, y, this.#width, data);\n    }\n\n    return horizontalCost + verticalCost + diagonalCost * 0.5;\n  }\n\n  #computeFullEnergyMap(\n    width: number = this.#width,\n    height: number = this.#height\n  ): EnergyMapData[] {\n    const energyMapData = new Array(height);\n\n    for (let y = 0; y < height; y++) {\n      energyMapData[y] = new Uint16Array(width) as EnergyMapData;\n\n      for (let x = 0; x < width; x++) {\n        const backwardEnergy = this.#computeBackwardEnergy(x, y);\n        const forwardEnergy = this.#computeForwardEnergy(x, y);\n\n        const totalEnergy = backwardEnergy + this.#forwardEnergyWeight * forwardEnergy;\n        energyMapData[y]![x] = Math.min(65535, Math.max(0, Math.round(totalEnergy)));\n      }\n    }\n\n    return energyMapData;\n  }\n\n  get width(): number {\n    return this.#width;\n  }\n\n  get height(): number {\n    return this.#height;\n  }\n\n  get energyMap(): readonly EnergyMapData[] {\n    return this.#data;\n  }\n\n  get originalIndices(): readonly EnergyMapIndices[] {\n    return this.#originalIndices;\n  }\n\n  removeSeam(xIndices: Uint16Array): void {\n    for (let y = 0; y < this.#height; y++) {\n      const xToRemove = xIndices[y]!;\n      this.#data[y] = deleteArrayIndices(this.#data[y]!, [xToRemove]);\n      this.#originalIndices[y] = deleteArrayIndices(this.#originalIndices[y]!, [xToRemove]);\n    }\n    this.#width--;\n\n    // Update image data for forward energy calculations\n    const newImageData = new ImageData(this.#width, this.#height);\n    let writeIndex = 0;\n\n    for (let y = 0; y < this.#height; y++) {\n      const seamX = xIndices[y]!;\n      for (let x = 0; x < this.#width + 1; x++) {\n        if (x !== seamX) {\n          const readIndex = (y * (this.#width + 1) + x) * 4;\n          newImageData.data[writeIndex] = this.#imageData.data[readIndex]!;\n          newImageData.data[writeIndex + 1] = this.#imageData.data[readIndex + 1]!;\n          newImageData.data[writeIndex + 2] = this.#imageData.data[readIndex + 2]!;\n          newImageData.data[writeIndex + 3] = this.#imageData.data[readIndex + 3]!;\n          writeIndex += 4;\n        }\n      }\n    }\n\n    this.#imageData = newImageData;\n\n    // Recompute affected energy values around the removed seam\n    const g = (colInNewCoord: number, removedOriginalIndex: number) =>\n      colInNewCoord < removedOriginalIndex ? colInNewCoord : colInNewCoord + 1;\n\n    for (let y = 0; y < this.#height; y++) {\n      const removedColOrigIdx = xIndices[y]!;\n\n      const columnsInNewDataToUpdate: number[] = [];\n      if (removedColOrigIdx > 0) {\n        columnsInNewDataToUpdate.push(removedColOrigIdx - 1);\n      }\n      if (removedColOrigIdx < this.#width) {\n        columnsInNewDataToUpdate.push(removedColOrigIdx);\n      }\n\n      for (const xCurrent of columnsInNewDataToUpdate) {\n        const backwardEnergy = this.#computeBackwardEnergy(xCurrent, y);\n        const forwardEnergy = this.#computeForwardEnergy(xCurrent, y);\n        const totalEnergy = backwardEnergy + this.#forwardEnergyWeight * forwardEnergy;\n        this.#data[y]![xCurrent] = Math.min(65535, Math.max(0, Math.round(totalEnergy)));\n      }\n    }\n  }\n\n  removeSeams(seams: Uint16Array[]): void {\n    if (seams.length === 0) {\n      return;\n    }\n\n    const numSeamsToRemove = seams.length;\n\n    for (let y = 0; y < this.#height; y++) {\n      const indicesToRemoveForRow: number[] = seams\n        .map((seamPath) => seamPath[y]!)\n        .sort((a, b) => a - b);\n\n      this.#data[y] = deleteArrayIndices(this.#data[y]!, indicesToRemoveForRow);\n      this.#grayscaleMap[y] = deleteArrayIndices(this.#grayscaleMap[y]!, indicesToRemoveForRow);\n      this.#originalIndices[y] = deleteArrayIndices(\n        this.#originalIndices[y]!,\n        indicesToRemoveForRow\n      );\n    }\n\n    this.#width -= numSeamsToRemove;\n\n    // Update image data by removing multiple seams\n    const newImageData = new ImageData(this.#width, this.#height);\n    let writeIndex = 0;\n\n    for (let y = 0; y < this.#height; y++) {\n      const indicesToRemove = seams.map((seamPath) => seamPath[y]!).sort((a, b) => a - b);\n      let removeIndex = 0;\n\n      for (let x = 0; x < this.#width + numSeamsToRemove; x++) {\n        if (removeIndex < indicesToRemove.length && x === indicesToRemove[removeIndex]) {\n          removeIndex++;\n          continue;\n        }\n\n        const readIndex = (y * (this.#width + numSeamsToRemove) + x) * 4;\n        newImageData.data[writeIndex] = this.#imageData.data[readIndex]!;\n        newImageData.data[writeIndex + 1] = this.#imageData.data[readIndex + 1]!;\n        newImageData.data[writeIndex + 2] = this.#imageData.data[readIndex + 2]!;\n        newImageData.data[writeIndex + 3] = this.#imageData.data[readIndex + 3]!;\n        writeIndex += 4;\n      }\n    }\n\n    this.#imageData = newImageData;\n    this.#data = this.#computeFullEnergyMap();\n  }\n\n  getEnergyMapAsImageData(width: number = this.#width, height: number = this.#height): ImageData {\n    const energyMapData = this.#computeFullEnergyMap(width, height);\n\n    // Find min and max energy values for normalization\n    let minEnergy = Infinity;\n    let maxEnergy = 0;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const energy = energyMapData[y]![x]!;\n        if (energy < minEnergy) minEnergy = energy;\n        if (energy > maxEnergy) maxEnergy = energy;\n      }\n    }\n\n    const energyRange = maxEnergy - minEnergy;\n    const imageData = new ImageData(width, height);\n    const data = imageData.data;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const index = (y * width + x) * 4;\n        const energy = energyMapData[y]![x]!;\n\n        // Normalize energy to 0-255 range\n        const normalizedEnergy =\n          energyRange > 0 ? Math.round(((energy - minEnergy) / energyRange) * 255) : 0;\n\n        // Set RGB channels to the same value for grayscale\n        data[index] = normalizedEnergy; // R\n        data[index + 1] = normalizedEnergy; // G\n        data[index + 2] = normalizedEnergy; // B\n        data[index + 3] = 255; // A (100% alpha)\n      }\n    }\n\n    return imageData;\n  }\n}\n", "import type { Tagged } from 'type-fest';\nimport { deleteArrayIndices } from '../../utils/delete-array-indicies/delete-array-indicies';\nimport { GrayscalePixelArray } from '../../utils/types/types';\n\nfunction getPixelIndex(x: number, y: number, width: number): number {\n  return (y * width + x) * 4;\n}\n\nfunction getGrayscale(x: number, y: number, width: number, data: Uint8ClampedArray): number {\n  if (x < 0 || x >= width || y < 0 || y >= Math.floor(data.length / (width * 4))) {\n    return 0;\n  }\n  const i = getPixelIndex(x, y, width);\n\n  return 0.299 * data[i]! + 0.587 * data[i + 1]! + (0.114 * data[i + 2]! * data[i + 3]!) / 255;\n}\n\nfunction getColorDistance(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  width: number,\n  data: Uint8ClampedArray\n): number {\n  if (\n    x1 < 0 ||\n    x1 >= width ||\n    y1 < 0 ||\n    y1 >= Math.floor(data.length / (width * 4)) ||\n    x2 < 0 ||\n    x2 >= width ||\n    y2 < 0 ||\n    y2 >= Math.floor(data.length / (width * 4))\n  ) {\n    return 0;\n  }\n\n  const i1 = getPixelIndex(x1, y1, width);\n  const i2 = getPixelIndex(x2, y2, width);\n\n  const dr = data[i1]! - data[i2]!;\n  const dg = data[i1 + 1]! - data[i2 + 1]!;\n  const db = data[i1 + 2]! - data[i2 + 2]!;\n\n  return Math.sqrt(dr * dr + dg * dg + db * db);\n}\n\nfunction getRegionVariance(\n  centerX: number,\n  centerY: number,\n  radius: number,\n  width: number,\n  data: Uint8ClampedArray\n): number {\n  let sum = 0;\n  let sumSquares = 0;\n  let count = 0;\n\n  for (let dy = -radius; dy <= radius; dy++) {\n    for (let dx = -radius; dx <= radius; dx++) {\n      const x = centerX + dx;\n      const y = centerY + dy;\n\n      if (x >= 0 && x < width && y >= 0 && y < Math.floor(data.length / (width * 4))) {\n        const gray = getGrayscale(x, y, width, data);\n        sum += gray;\n        sumSquares += gray * gray;\n        count++;\n      }\n    }\n  }\n\n  if (count < 2) return 0;\n\n  const mean = sum / count;\n  const variance = sumSquares / count - mean * mean;\n  return Math.sqrt(variance); // Return standard deviation\n}\n\ntype EnergyMapData = Tagged<Uint16Array, 'energyMapData'>;\ntype EnergyMapIndices = Tagged<Uint32Array, 'energyMapIndices'>;\n\nexport class BoundaryAwareEnergyMap {\n  #data: EnergyMapData[];\n  #width: number;\n  #height: number;\n  #grayscaleMap: Uint8Array[];\n  #originalIndices: EnergyMapIndices[];\n  #imageData: ImageData;\n  #boundaryPenaltyWeight: number;\n  #uniformityThreshold: number;\n  #edgeThreshold: number;\n\n  constructor(\n    imageData: ImageData,\n    boundaryPenaltyWeight: number = 5.0,\n    uniformityThreshold: number = 10.0,\n    edgeThreshold: number = 20.0,\n    maskData?: GrayscalePixelArray\n  ) {\n    this.#width = imageData.width;\n    this.#height = imageData.height;\n    this.#imageData = imageData;\n    this.#boundaryPenaltyWeight = boundaryPenaltyWeight;\n    this.#uniformityThreshold = uniformityThreshold;\n    this.#edgeThreshold = edgeThreshold;\n    this.#data = new Array(this.#height);\n    this.#grayscaleMap = new Array(this.#height);\n    this.#originalIndices = new Array(this.#height);\n\n    this.#fillOriginalIndices();\n    this.#computeGrayscaleMap(imageData);\n    this.#data = this.#computeFullEnergyMap();\n  }\n\n  #fillOriginalIndices(): void {\n    for (let y = 0; y < this.#height; y++) {\n      this.#originalIndices[y] = new Uint32Array(this.#width) as EnergyMapIndices;\n      for (let x = 0; x < this.#width; x++) {\n        this.#originalIndices[y]![x] = y * this.#width + x;\n      }\n    }\n  }\n\n  #computeGrayscaleMap(imageData: ImageData): void {\n    for (let y = 0; y < this.#height; y++) {\n      this.#grayscaleMap[y] = new Uint8Array(this.#width);\n      for (let x = 0; x < this.#width; x++) {\n        this.#grayscaleMap[y]![x] = getGrayscale(x, y, this.#width, imageData.data);\n      }\n    }\n  }\n\n  #computeGradientEnergy(x: number, y: number): number {\n    // Sobel operator for gradient energy\n    const y1 = Math.max(0, y - 1);\n    const y3 = Math.min(this.#height - 1, y + 1);\n    const x1 = Math.max(0, x - 1);\n    const x3 = Math.min(this.#width - 1, x + 1);\n\n    const prevRow = this.#grayscaleMap[y1]!;\n    const currentRow = this.#grayscaleMap[y]!;\n    const nextRow = this.#grayscaleMap[y3]!;\n\n    const gx =\n      -prevRow[x1]! +\n      prevRow[x3]! +\n      -currentRow[x1]! * 2 +\n      currentRow[x3]! * 2 +\n      -nextRow[x1]! +\n      nextRow[x3]!;\n\n    const gy =\n      -prevRow[x1]! +\n      -prevRow[x]! * 2 +\n      -prevRow[x3]! +\n      nextRow[x1]! +\n      nextRow[x]! * 2 +\n      nextRow[x3]!;\n\n    return (gx < 0 ? -gx : gx) + (gy < 0 ? -gy : gy);\n  }\n\n  #computeForwardEnergy(x: number, y: number): number {\n    // Forward energy: cost of connecting neighbors when this pixel is removed\n    const data = this.#imageData.data;\n\n    const leftX = x - 1;\n    const rightX = x + 1;\n    const horizontalCost = getColorDistance(leftX, y, rightX, y, this.#width, data);\n\n    const topY = y - 1;\n    const bottomY = y + 1;\n    const verticalCost = getColorDistance(x, topY, x, bottomY, this.#width, data);\n\n    return horizontalCost + verticalCost;\n  }\n\n  #detectBoundaryPenalty(x: number, y: number): number {\n    const data = this.#imageData.data;\n\n    // Check if this pixel is on a meaningful edge\n    const gradientEnergy = this.#computeGradientEnergy(x, y);\n    if (gradientEnergy < this.#edgeThreshold * 0.3) {\n      return 0; // Very weak edge, no penalty\n    }\n\n    // Check regions to the left and right\n    const leftVariance = getRegionVariance(x - 3, y, 2, this.#width, data);\n    const rightVariance = getRegionVariance(x + 3, y, 2, this.#width, data);\n\n    // Check regions above and below\n    const topVariance = getRegionVariance(x, y - 3, 2, this.#width, data);\n    const bottomVariance = getRegionVariance(x, y + 3, 2, this.#width, data);\n\n    let boundaryStrength = 0;\n\n    // Strategy 1: Perfect boundaries (one side very uniform - like building vs sky)\n    const minVariance = Math.min(leftVariance, rightVariance, topVariance, bottomVariance);\n    if (minVariance < this.#uniformityThreshold * 0.5) {\n      // Only very uniform regions count as perfect boundaries\n      const uniformityFactor = Math.max(\n        0,\n        (this.#uniformityThreshold * 0.5 - minVariance) / (this.#uniformityThreshold * 0.5)\n      );\n      boundaryStrength = Math.max(boundaryStrength, uniformityFactor * 0.3);\n    }\n\n    // Strategy 2: Texture difference boundaries (different variance on each side - like building vs trees)\n    const horizontalDiff = Math.abs(leftVariance - rightVariance);\n    const verticalDiff = Math.abs(topVariance - bottomVariance);\n    const maxTextureDiff = Math.max(horizontalDiff, verticalDiff);\n\n    if (maxTextureDiff > this.#uniformityThreshold * 4 && gradientEnergy > this.#edgeThreshold) {\n      // Much higher threshold for texture differences, and require strong gradient\n      const textureFactor = Math.min(1, maxTextureDiff / (this.#uniformityThreshold * 8));\n      boundaryStrength = Math.max(boundaryStrength, textureFactor * 0.2);\n    }\n\n    // Strategy 3: Strong edges get protection regardless (catch-all for missed boundaries)\n    if (gradientEnergy > this.#edgeThreshold * 2.5) {\n      // Only very strong edges get this protection\n      const strongEdgeFactor = Math.min(1, gradientEnergy / (this.#edgeThreshold * 4));\n      boundaryStrength = Math.max(boundaryStrength, strongEdgeFactor * 0.15);\n    }\n\n    if (boundaryStrength > 0) {\n      // Much smaller base penalty\n      const edgeFactor = Math.min(1, gradientEnergy / (this.#edgeThreshold * 2));\n      return boundaryStrength * edgeFactor * 200; // Reduced from 1000 to 200\n    }\n\n    return 0;\n  }\n\n  #computeFullEnergyMap(\n    width: number = this.#width,\n    height: number = this.#height\n  ): EnergyMapData[] {\n    const energyMapData = new Array(height);\n\n    for (let y = 0; y < height; y++) {\n      energyMapData[y] = new Uint16Array(width) as EnergyMapData;\n\n      for (let x = 0; x < width; x++) {\n        const gradientEnergy = this.#computeGradientEnergy(x, y);\n        const forwardEnergy = this.#computeForwardEnergy(x, y);\n        const boundaryPenalty = this.#detectBoundaryPenalty(x, y);\n\n        const totalEnergy =\n          gradientEnergy + forwardEnergy + this.#boundaryPenaltyWeight * boundaryPenalty;\n        energyMapData[y]![x] = Math.min(65535, Math.max(0, Math.round(totalEnergy)));\n      }\n    }\n\n    return energyMapData;\n  }\n\n  get width(): number {\n    return this.#width;\n  }\n\n  get height(): number {\n    return this.#height;\n  }\n\n  get energyMap(): readonly EnergyMapData[] {\n    return this.#data;\n  }\n\n  get originalIndices(): readonly EnergyMapIndices[] {\n    return this.#originalIndices;\n  }\n\n  removeSeam(xIndices: Uint16Array): void {\n    for (let y = 0; y < this.#height; y++) {\n      const xToRemove = xIndices[y]!;\n      this.#data[y] = deleteArrayIndices(this.#data[y]!, [xToRemove]);\n      this.#originalIndices[y] = deleteArrayIndices(this.#originalIndices[y]!, [xToRemove]);\n    }\n    this.#width--;\n\n    // Update image data for forward energy calculations\n    const newImageData = new ImageData(this.#width, this.#height);\n    let writeIndex = 0;\n\n    for (let y = 0; y < this.#height; y++) {\n      const seamX = xIndices[y]!;\n      for (let x = 0; x < this.#width + 1; x++) {\n        if (x !== seamX) {\n          const readIndex = (y * (this.#width + 1) + x) * 4;\n          newImageData.data[writeIndex] = this.#imageData.data[readIndex]!;\n          newImageData.data[writeIndex + 1] = this.#imageData.data[readIndex + 1]!;\n          newImageData.data[writeIndex + 2] = this.#imageData.data[readIndex + 2]!;\n          newImageData.data[writeIndex + 3] = this.#imageData.data[readIndex + 3]!;\n          writeIndex += 4;\n        }\n      }\n    }\n\n    this.#imageData = newImageData;\n\n    // Recompute affected energy values around the removed seam\n    for (let y = 0; y < this.#height; y++) {\n      const removedColOrigIdx = xIndices[y]!;\n\n      const columnsInNewDataToUpdate: number[] = [];\n      if (removedColOrigIdx > 0) {\n        columnsInNewDataToUpdate.push(removedColOrigIdx - 1);\n      }\n      if (removedColOrigIdx < this.#width) {\n        columnsInNewDataToUpdate.push(removedColOrigIdx);\n      }\n\n      for (const xCurrent of columnsInNewDataToUpdate) {\n        const gradientEnergy = this.#computeGradientEnergy(xCurrent, y);\n        const forwardEnergy = this.#computeForwardEnergy(xCurrent, y);\n        const boundaryPenalty = this.#detectBoundaryPenalty(xCurrent, y);\n\n        const totalEnergy =\n          gradientEnergy + forwardEnergy + this.#boundaryPenaltyWeight * boundaryPenalty;\n        this.#data[y]![xCurrent] = Math.min(65535, Math.max(0, Math.round(totalEnergy)));\n      }\n    }\n  }\n\n  removeSeams(seams: Uint16Array[]): void {\n    if (seams.length === 0) {\n      return;\n    }\n\n    const numSeamsToRemove = seams.length;\n\n    for (let y = 0; y < this.#height; y++) {\n      const indicesToRemoveForRow: number[] = seams\n        .map((seamPath) => seamPath[y]!)\n        .sort((a, b) => a - b);\n\n      this.#data[y] = deleteArrayIndices(this.#data[y]!, indicesToRemoveForRow);\n      this.#grayscaleMap[y] = deleteArrayIndices(this.#grayscaleMap[y]!, indicesToRemoveForRow);\n      this.#originalIndices[y] = deleteArrayIndices(\n        this.#originalIndices[y]!,\n        indicesToRemoveForRow\n      );\n    }\n\n    this.#width -= numSeamsToRemove;\n\n    // Update image data by removing multiple seams\n    const newImageData = new ImageData(this.#width, this.#height);\n    let writeIndex = 0;\n\n    for (let y = 0; y < this.#height; y++) {\n      const indicesToRemove = seams.map((seamPath) => seamPath[y]!).sort((a, b) => a - b);\n      let removeIndex = 0;\n\n      for (let x = 0; x < this.#width + numSeamsToRemove; x++) {\n        if (removeIndex < indicesToRemove.length && x === indicesToRemove[removeIndex]) {\n          removeIndex++;\n          continue;\n        }\n\n        const readIndex = (y * (this.#width + numSeamsToRemove) + x) * 4;\n        newImageData.data[writeIndex] = this.#imageData.data[readIndex]!;\n        newImageData.data[writeIndex + 1] = this.#imageData.data[readIndex + 1]!;\n        newImageData.data[writeIndex + 2] = this.#imageData.data[readIndex + 2]!;\n        newImageData.data[writeIndex + 3] = this.#imageData.data[readIndex + 3]!;\n        writeIndex += 4;\n      }\n    }\n\n    this.#imageData = newImageData;\n    this.#data = this.#computeFullEnergyMap();\n  }\n\n  getEnergyMapAsImageData(width: number = this.#width, height: number = this.#height): ImageData {\n    const energyMapData = this.#computeFullEnergyMap(width, height);\n\n    // Find min and max energy values for normalization\n    let minEnergy = Infinity;\n    let maxEnergy = 0;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const energy = energyMapData[y]![x]!;\n        if (energy < minEnergy) minEnergy = energy;\n        if (energy > maxEnergy) maxEnergy = energy;\n      }\n    }\n\n    const energyRange = maxEnergy - minEnergy;\n    const imageData = new ImageData(width, height);\n    const data = imageData.data;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const index = (y * width + x) * 4;\n        const energy = energyMapData[y]![x]!;\n\n        // Normalize energy to 0-255 range\n        const normalizedEnergy =\n          energyRange > 0 ? Math.round(((energy - minEnergy) / energyRange) * 255) : 0;\n\n        // Set RGB channels to the same value for grayscale\n        data[index] = normalizedEnergy; // R\n        data[index + 1] = normalizedEnergy; // G\n        data[index + 2] = normalizedEnergy; // B\n        data[index + 3] = 255; // A (100% alpha)\n      }\n    }\n\n    return imageData;\n  }\n}\n", "import { SobelEnergyMap } from '../sobel-energy-map/sobel-energy-map';\nimport { DualEnergyMap } from '../dual-energy-map/dual-energy-map';\nimport { BoundaryAwareEnergyMap } from '../boundary-aware-energy-map/boundary-aware-energy-map';\nimport { GrayscalePixelArray } from '../../utils/types/types';\n\n// Energy map algorithm types\nexport type EnergyMapAlgorithm = 'sobel' | 'dual' | 'boundary-aware';\n\n// Configuration: change this to switch energy map implementations\nconst ENERGY_ALGORITHM: EnergyMapAlgorithm = 'sobel';\n\n// Algorithm-specific configuration\nconst CONFIG = {\n  dual: {\n    forwardEnergyWeight: 1.0,\n  },\n  'boundary-aware': {\n    boundaryPenaltyWeight: 5.0,\n    uniformityThreshold: 10.0,\n    edgeThreshold: 20.0,\n  },\n  sobel: {},\n} as const;\n\n// Factory function to create energy maps\nfunction createEnergyMap(\n  algorithm: EnergyMapAlgorithm,\n  imageData: ImageData,\n  maskData?: GrayscalePixelArray\n) {\n  switch (algorithm) {\n    case 'sobel':\n      return new SobelEnergyMap(imageData, maskData);\n\n    case 'dual':\n      return new DualEnergyMap(imageData, CONFIG.dual.forwardEnergyWeight, maskData);\n\n    case 'boundary-aware':\n      return new BoundaryAwareEnergyMap(\n        imageData,\n        CONFIG['boundary-aware'].boundaryPenaltyWeight,\n        CONFIG['boundary-aware'].uniformityThreshold,\n        CONFIG['boundary-aware'].edgeThreshold,\n        maskData\n      );\n\n    default:\n      const _exhaustive: never = algorithm;\n      throw new Error(`Unknown energy map algorithm: ${algorithm}`);\n  }\n}\n\n// Export the chosen implementation as \"EnergyMap\"\nexport const EnergyMap = class EnergyMap {\n  private impl: SobelEnergyMap | DualEnergyMap | BoundaryAwareEnergyMap;\n\n  constructor(imageData: ImageData, maskData?: GrayscalePixelArray) {\n    this.impl = createEnergyMap(ENERGY_ALGORITHM, imageData, maskData);\n  }\n\n  get width() {\n    return this.impl.width;\n  }\n  get height() {\n    return this.impl.height;\n  }\n  get energyMap() {\n    return this.impl.energyMap;\n  }\n  get originalIndices() {\n    return this.impl.originalIndices;\n  }\n\n  removeSeam(xIndices: Uint16Array) {\n    return this.impl.removeSeam(xIndices);\n  }\n  removeSeams(seams: Uint16Array[]) {\n    return this.impl.removeSeams(seams);\n  }\n  getEnergyMapAsImageData(width?: number, height?: number) {\n    return this.impl.getEnergyMapAsImageData(width, height);\n  }\n};\n\nexport type EnergyMap = InstanceType<typeof EnergyMap>;\n\n// Export the original classes and factory for direct access\nexport { SobelEnergyMap, DualEnergyMap, BoundaryAwareEnergyMap, createEnergyMap };\n", "import { EnergyMap } from '../energy-map/energy-map';\nimport { ImageLoader } from '../../utils/image-loader/image-loader';\nimport { GrayscalePixelArray, SeamGenerator, SeamPixelPriorityGrid } from '../../utils/types/types';\nimport { getGrayscaleImageData } from '../grayscale/grayscale';\n\nexport type BaseGeneratorOptions = {\n  imageLoader: ImageLoader;\n  maskLoader?: ImageLoader;\n};\n\nexport abstract class BaseGenerator implements SeamGenerator {\n  protected imageLoader: ImageLoader;\n  protected maskLoader?: ImageLoader;\n  protected energyMapPromise: Promise<EnergyMap>;\n  protected seamGrid: SeamPixelPriorityGrid = new Uint16Array() as SeamPixelPriorityGrid;\n  protected generatedSeams = 0;\n\n  constructor(options: BaseGeneratorOptions) {\n    this.imageLoader = options.imageLoader;\n    this.maskLoader = options.maskLoader;\n    this.energyMapPromise = this.createEnergyMap();\n  }\n\n  protected async createEnergyMap(): Promise<EnergyMap> {\n    const imageData = await this.imageLoader.imageData;\n    const maskData = await this.getMaskData();\n\n    this.seamGrid = new Uint16Array(imageData.width * imageData.height).fill(\n      65535\n    ) as SeamPixelPriorityGrid;\n\n    return new EnergyMap(imageData, maskData);\n  }\n\n  abstract generateSeamBatch(): Promise<void>;\n\n  protected async getMaskData(): Promise<GrayscalePixelArray | undefined> {\n    if (!this.maskLoader) return undefined;\n\n    const maskData = await this.maskLoader.imageData;\n    return getGrayscaleImageData(maskData, false);\n  }\n\n  async generateSeamGrid(minSeams: number): Promise<SeamPixelPriorityGrid> {\n    const { width } = await this.imageLoader.image;\n\n    if (width < minSeams) {\n      throw new Error(`Cannot generate ${minSeams} seams for image with width ${width}`);\n    }\n\n    while (this.generatedSeams < minSeams) {\n      await this.generateSeamBatch();\n    }\n\n    return this.seamGrid;\n  }\n}\n", "import { deterministicBinaryRnd } from '../../utils/deterministic-binary-rnd/deterministic-binary-rnd';\nimport { EnergyMap } from '../energy-map/energy-map';\nimport { BaseGenerator, BaseGeneratorOptions } from '../base-generator/base-generator';\n\n/**\n * The general idea here is to create random, but deterministic seams for the entire image.  They\n * need to be deterministic so that we can ensure 100% image coverage, and that no 2 seams travel\n * through the same pixel.  Then we sort them by energy, and remove a batch of the lowest energy\n * seams.  We then restart the process from scratch until we have the desired number of seams.\n *\n * The random seams are created by a deterministic random number generator basically deciding if\n * every pair of pixels should continue straight down, or if they should be swapped with one\n * another.  Repeat for the entire image and voila, we have random deterministic seams.\n *\n * So the entire algorithm is O(n) where n is the number of pixels in the image.\n */\n\ntype RandomSpecificOptions = {\n  batchPercentage?: number;\n  minBatchSize?: number;\n};\n\nexport type RandomGeneratorOptions = BaseGeneratorOptions & RandomSpecificOptions;\n\ntype RandomInstanceOptions = BaseGeneratorOptions & Required<RandomSpecificOptions>;\n\nconst defaultOptions: Required<RandomSpecificOptions> = {\n  batchPercentage: 0.05,\n  minBatchSize: 10,\n};\n\nexport class RandomGenerator extends BaseGenerator {\n  protected connections: Int8Array[] = [];\n  protected options: RandomInstanceOptions;\n\n  constructor(options: RandomGeneratorOptions) {\n    super(options);\n    this.options = { ...defaultOptions, ...options };\n  }\n\n  setBatchPercentage(percentage: number): void {\n    this.options.batchPercentage = percentage;\n  }\n\n  async generateSeamBatch(): Promise<void> {\n    const energyMap = await this.energyMapPromise;\n    const originalIndices = energyMap.originalIndices;\n    const currentWidth = energyMap.width;\n    const currentHeight = energyMap.height;\n    this.generateConnections(currentWidth, currentHeight);\n    const seams = Array.from({ length: currentWidth }, (_, ix) => this.getSeam(energyMap, ix));\n    seams.sort((a, b) => a.energy - b.energy);\n\n    const batchSize = Math.max(\n      // the '>> 1 << 1' ensures that the batch size is even.\n      (Math.ceil(currentWidth * this.options.batchPercentage) >> 1) << 1,\n      Math.min(this.options.minBatchSize, currentWidth)\n    );\n    const batchSeams = seams.slice(0, batchSize);\n\n    let seamIndex = this.generatedSeams;\n    for (let i = 0; i < batchSeams.length; i++) {\n      const seam = batchSeams[i]!;\n      seam.seam.forEach((x, y) => {\n        const originalIndex = originalIndices[y]![x]!;\n        if (this.seamGrid[originalIndex] !== 65535) {\n          throw new Error('Seam overlap detected');\n        }\n        this.seamGrid[originalIndex] = seamIndex;\n      });\n      seamIndex++;\n    }\n\n    energyMap.removeSeams(batchSeams.map((seam) => seam.seam));\n    this.generatedSeams += batchSeams.length;\n  }\n\n  protected generateConnections(width: number, height: number): void {\n    const rndGenerator = deterministicBinaryRnd(width * height + 1);\n\n    this.connections = Array.from({ length: height }, () => new Int8Array(width));\n    const lastColIx = width - 1;\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        if (x === lastColIx || rndGenerator(y * width + x)) {\n          this.connections[y]![x] = 0;\n        } else {\n          this.connections[y]![x] = 1;\n          this.connections[y]![x + 1] = -1;\n          x++;\n        }\n      }\n    }\n  }\n\n  protected getSeam(energyMap: EnergyMap, ix: number): { seam: Uint16Array; energy: number } {\n    const height = energyMap.height;\n    const seam = new Uint16Array(height);\n    const energyMapData = energyMap.energyMap;\n    let energy = 0;\n    let lastX = ix;\n\n    for (let y = 0; y < height; y++) {\n      seam[y] = lastX = lastX + this.connections[y]![lastX]!;\n      energy += energyMapData[y]![lastX]!;\n    }\n\n    return { seam, energy };\n  }\n}\n", "import { RandomGenerator, RandomGeneratorOptions } from '../random-generator/random-generator';\nimport {\n  PredictiveGenerator,\n  PredictiveGeneratorOptions,\n} from '../predictive-generator/predictive-generator';\n\nexport type GeneratorOptions =\n  | ({ generator: 'random' } & RandomGeneratorOptions)\n  | ({ generator: 'predictive' } & PredictiveGeneratorOptions);\n\nfunction getGenerator(options: GeneratorOptions, specificType?: string) {\n  if (\n    (!specificType || specificType === 'random') &&\n    typeof RANDOM_GENERATOR !== 'undefined' &&\n    RANDOM_GENERATOR\n  ) {\n    return new RandomGenerator(options);\n  }\n\n  if (\n    (!specificType || specificType === 'predictive') &&\n    typeof PREDICTIVE_GENERATOR !== 'undefined' &&\n    PREDICTIVE_GENERATOR\n  ) {\n    return new PredictiveGenerator(options);\n  }\n\n  return null;\n}\n\nexport function createGenerator(options: GeneratorOptions) {\n  const generator = getGenerator(options, options.generator) || getGenerator(options);\n\n  if (!generator) {\n    throw new Error(`[Fluid-Img] No generators are available.`);\n  }\n\n  return generator;\n}\n", "export class Profiler {\n  #log: (str: string) => void;\n  #times = new Map<\n    string,\n    { startTime: number; minLoggingTime: number; totalNestedTime: number }\n  >();\n  #activeStack: string[] = [];\n\n  constructor(log: (str: string) => void) {\n    this.#log = log;\n  }\n\n  start(name: string, minLoggingTime: number = 0): void {\n    this.#times.set(name, {\n      startTime: performance.now(),\n      minLoggingTime,\n      totalNestedTime: 0,\n    });\n    this.#activeStack.push(name);\n  }\n\n  end(name: string): void {\n    const { startTime, minLoggingTime, totalNestedTime } = this.#times.get(name)!;\n    const elapsedTime = performance.now() - startTime;\n\n    if (elapsedTime < minLoggingTime) return;\n\n    const stackSize = this.#activeStack.length;\n    if (stackSize > 1) {\n      const parentName = this.#activeStack[stackSize - 2]!;\n      const parentData = this.#times.get(parentName)!;\n      parentData.totalNestedTime += elapsedTime;\n    }\n\n    if (totalNestedTime > 0) {\n      this.#log(\n        `${name}: ${(elapsedTime - totalNestedTime).toFixed(2)}ms (${elapsedTime.toFixed(2)}ms)`\n      );\n    } else {\n      this.#log(`${name}: ${(elapsedTime - totalNestedTime).toFixed(2)}ms`);\n    }\n\n    this.#activeStack.pop();\n    this.#times.delete(name);\n  }\n}\n", "export function errorBoundary<T extends (this: any, ...args: any[]) => any>(\n  originalMethod: T\n): (this: ThisParameterType<T>, ...args: Parameters<T>) => ReturnType<T> | void {\n  return function replacementMethod(\n    this: ThisParameterType<T>,\n    ...args: Parameters<T>\n  ): ReturnType<T> | void {\n    if (this.hasFailed) {\n      return;\n    }\n\n    try {\n      const result = originalMethod.apply(this, args);\n      if (result && typeof result.catch === 'function') {\n        return result.catch((error: unknown) => {\n          this.handleFailure(error);\n        });\n      }\n      return result;\n    } catch (error) {\n      this.handleFailure(error);\n    }\n  };\n}\n", "export function toKebabCase(str: string): string {\n  return str.replace(/([A-Z])/g, '-$1').toLowerCase();\n}\n", "{\n  \"name\": \"Fluid-Img\",\n  \"version\": \"0.1.0\",\n  \"description\": \"A web component for displaying images that intelligently resize to fit most any container.\",\n  \"author\": \"Voice NPO, Inc.\",\n  \"license\": \"Fluid-Img Revenue-Limited License\",\n  \"type\": \"module\",\n  \"main\": \"./dist/fluid-img.js\",\n  \"module\": \"./dist/fluid-img.js\",\n  \"types\": \"./dist/fluid-img.d.ts\",\n  \"files\": [\n    \"dist\",\n    \"src\",\n    \"README.md\"\n  ],\n  \"exports\": {\n    \".\": \"./dist/fluid-img.js\",\n    \"./random\": \"./dist/fluid-img-random.js\",\n    \"./predictive\": \"./dist/fluid-img-predictive.js\"\n  },\n  \"scripts\": {\n    \"test\": \"vitest -t \\\"^[^@]+$\\\"\",\n    \"test:live\": \"vitest -t \\\"@LIVE\\\"\",\n    \"test:watch\": \"vitest watch\",\n    \"build\": \"npm run build:esbuild:all && npm run build:esbuild:random && npm run build:esbuild:predictive && npm run build:esbuild:demo && npm run copy-to-docs\",\n    \"watch\": \"npm run watch:esbuild:all & npm run watch:esbuild:random & npm run watch:esbuild:predictive & npm run watch:esbuild:demo\",\n    \"build:esbuild\": \"esbuild src/renderer/web-component/web-component.ts --define:ALL_GENERATORS=false --define:RANDOM_GENERATOR=false --define:PREDICTIVE_GENERATOR=false --define:DEMO=false --bundle --minify --sourcemap --target=esnext\",\n    \"build:esbuild:demo\": \"npm run build:esbuild:all -- --define:DEMO=true --outfile=dist/fluid-img-demo.js\",\n    \"build:esbuild:all\": \"npm run build:esbuild -- --define:RANDOM_GENERATOR=true --define:PREDICTIVE_GENERATOR=true --outfile=dist/fluid-img.js\",\n    \"build:esbuild:random\": \"npm run build:esbuild -- --define:RANDOM_GENERATOR=true --outfile=dist/fluid-img-random.js\",\n    \"build:esbuild:predictive\": \"npm run build:esbuild -- --define:PREDICTIVE_GENERATOR=true --outfile=dist/fluid-img-predictive.js\",\n    \"watch:esbuild:demo\": \"npm run build:esbuild:demo -- --watch\",\n    \"watch:esbuild:all\": \"npm run build:esbuild:all -- --watch\",\n    \"watch:esbuild:random\": \"npm run build:esbuild:random -- --watch\",\n    \"watch:esbuild:predictive\": \"npm run build:esbuild:predictive -- --watch\",\n    \"copy-to-docs\": \"cp ./dist/* ./docs/public/.\"\n  },\n  \"devDependencies\": {\n    \"esbuild\": \"^0.25.4\",\n    \"eslint\": \"^9.27.0\",\n    \"prettier\": \"^3.5.3\",\n    \"tinybench\": \"^4.0.1\",\n    \"type-fest\": \"^4.41.0\",\n    \"typescript\": \"^5.8.3\",\n    \"vitest\": \"^3.1.4\"\n  },\n  \"dependencies\": {\n    \"@types/node\": \"^22.15.21\",\n    \"ansi-colors\": \"^4.1.3\",\n    \"canvas\": \"^3.1.0\",\n    \"cli-progress\": \"^3.12.0\",\n    \"commander\": \"^14.0.0\",\n    \"globby\": \"^14.1.0\"\n  }\n}\n", "import { toKebabCase } from '../to-kebab-case/to-kebab-case';\nimport { name as packageName } from '../../../package.json';\n\nexport const createOptionGetters = <T extends object>(options: T) => {\n  const getConstrainedNumber = (_name: keyof T, defaultValue: number, min = 0, max = 1): number => {\n    const name = String(_name);\n    const value = Number(options[toKebabCase(name) as keyof T] ?? defaultValue);\n    if (value < min || value > max) {\n      throw new Error(`[${packageName}] \\`${name}\\` must be between ${min} and ${max}.`);\n    }\n    return value;\n  };\n\n  const getBoolean = (_name: keyof T, defaultValue: boolean): boolean => {\n    const name = String(_name);\n    const value = options[toKebabCase(name) as keyof T];\n    // HTML boolean attributes: presence = true, absence (null) = false, value is ignored\n    if (value === null) return false; // Explicitly removed attribute\n    return value !== undefined ? true : defaultValue;\n  };\n\n  const getEnumValue = <E extends Record<string, string>>(\n    _name: keyof T,\n    enumObject: E,\n    defaultValue: E[keyof E]\n  ): E[keyof E] => {\n    const name = String(_name);\n    const value = options[toKebabCase(name) as keyof T] as string | undefined | null;\n\n    if (value === null || value === undefined) {\n      return defaultValue;\n    }\n\n    const enumValues = Object.values(enumObject);\n    if (enumValues.includes(value)) {\n      return value as E[keyof E];\n    }\n\n    console.warn(\n      `[${packageName}] Invalid value for ${name}: \"${value}\". Defaulting to \"${defaultValue}\".`\n    );\n    return defaultValue;\n  };\n\n  return { getConstrainedNumber, getBoolean, getEnumValue };\n};\n", "export const ScalingAxis = {\n  Horizontal: 'horizontal',\n  Vertical: 'vertical',\n  Auto: 'auto',\n  Dual: 'dual',\n} as const;\n\nexport type ScalingAxis = (typeof ScalingAxis)[keyof typeof ScalingAxis];\n", "import { ImageLoader } from '../../utils/image-loader/image-loader';\nimport { GeneratorType, SeamPixelPriorityGrid } from '../../utils/types/types';\nimport { createGenerator, GeneratorOptions } from '../../generator/generator/generator';\nimport { Profiler } from '../../utils/profiler/profiler';\nimport { errorBoundary } from '../../utils/error-boundary/error-boundary';\nimport { EnergyMap } from '../../generator/energy-map/energy-map';\nimport { createOptionGetters } from '../../utils/option-helpers/option-helpers';\nimport { ScalingAxis } from '../../utils/enums/enums';\n\nimport { name as packageName } from '../../../package.json';\n\nexport interface SeamGenerator {\n  generateSeamGrid(minSeams: number): Promise<SeamPixelPriorityGrid>;\n}\n\ntype GeneralOptions = {\n  generator?: GeneratorType;\n  carvingPriority?: number;\n  maxCarveUpSeamPercentage?: number;\n  maxCarveUpScale?: number;\n  maxCarveDownScale?: number;\n  scalingAxis?: ScalingAxis;\n  width?: number;\n  height?: number;\n  logger?: (message: string) => void;\n  showEnergyMap?: boolean;\n  demoMode?: boolean;\n};\n\ntype SeamOptions = GeneralOptions & GeneratorOptions;\ntype ProcessedSeamOptions = Required<GeneralOptions> & GeneratorOptions;\n\nexport type RendererConfig = {\n  parentNode: HTMLElement;\n  src: string;\n  generator?: GeneratorType;\n  mask?: string;\n} & SeamOptions;\n\nexport class Renderer {\n  private canvas!: HTMLCanvasElement;\n  private ctx!: CanvasRenderingContext2D;\n  private height = 0;\n  private width = 0;\n  private imageLoader!: ImageLoader;\n  private maskLoader?: ImageLoader;\n  private options!: ProcessedSeamOptions;\n  private generator!: SeamGenerator;\n  private redrawQueued = false;\n  private profiler!: Profiler;\n  private hasFailed = false;\n  private parentNode: HTMLElement;\n  private src: string;\n  private mask?: string;\n  private cachedEnergyMapImageData: ImageData | null = null;\n\n  setOptions = errorBoundary(this._setOptions).bind(this);\n  private redraw = errorBoundary(this._redraw).bind(this);\n\n  constructor(config: RendererConfig) {\n    const { parentNode, src, mask, ...options } = config;\n    this.parentNode = parentNode;\n    this.src = src;\n    this.mask = mask;\n\n    try {\n      this.options = this.validateAndApplyDefaults(options);\n      const rotate = this.options.scalingAxis === 'vertical';\n      this.profiler = new Profiler(this.options.logger);\n      this.imageLoader = new ImageLoader(src, { rotate, profiler: this.profiler });\n\n      if (this.mask) {\n        this.maskLoader = new ImageLoader(this.mask, { rotate });\n      }\n\n      this.generator = this.createGenerator();\n\n      this.initializeCanvas(parentNode);\n    } catch (e) {\n      this.handleFailure(e);\n    }\n  }\n\n  destroy(): void {\n    this.canvas.remove();\n  }\n\n  private createGenerator(): SeamGenerator {\n    const options = {\n      ...this.options,\n      imageLoader: this.imageLoader,\n      maskLoader: this.maskLoader,\n    };\n\n    return createGenerator(options);\n  }\n\n  private validateAndApplyDefaults(options: SeamOptions): ProcessedSeamOptions {\n    const { getBoolean, getConstrainedNumber, getEnumValue } = createOptionGetters(options);\n\n    const newOptions: SeamOptions = {\n      ...options,\n      carvingPriority: getConstrainedNumber('carvingPriority', 1),\n      maxCarveUpSeamPercentage: getConstrainedNumber('maxCarveUpSeamPercentage', 0.6),\n      maxCarveUpScale: getConstrainedNumber('maxCarveUpScale', 10, 1, 10),\n      maxCarveDownScale: getConstrainedNumber('maxCarveDownScale', 1),\n      scalingAxis: getEnumValue('scalingAxis', ScalingAxis, ScalingAxis.Horizontal),\n      logger: options.logger ?? (() => {}),\n      showEnergyMap: getBoolean('showEnergyMap', false),\n      demoMode: getBoolean('demoMode', false),\n    };\n\n    return newOptions as ProcessedSeamOptions;\n  }\n\n  private calculateDimensions(parentNode: HTMLElement): { width: number; height: number } {\n    let { width, height } = this.options;\n    if (width === undefined || height === undefined) {\n      const parentNodeSize = parentNode.getBoundingClientRect();\n      width = width ?? parentNodeSize.width;\n      height = height ?? parentNodeSize.height;\n    }\n\n    return { width, height };\n  }\n\n  private initializeCanvas(parentNode: HTMLElement): void {\n    const { width, height } = this.calculateDimensions(parentNode);\n\n    this.canvas = document.createElement('canvas');\n    this.ctx = this.canvas.getContext('2d')!;\n    this.canvas.width = this.width = width;\n    this.canvas.height = this.height = height;\n    this.canvas.style.display = 'block';\n\n    parentNode.appendChild(this.canvas);\n\n    this.queueRedraw();\n  }\n\n  setSize(width: number, height: number): void {\n    this.width = width;\n    this.height = height;\n    this.queueRedraw();\n  }\n\n  setWidth(width: number): void {\n    this.width = width;\n    this.queueRedraw();\n  }\n\n  setHeight(height: number): void {\n    this.height = height;\n    this.queueRedraw();\n  }\n\n  private _setOptions(options: Partial<SeamOptions>): void {\n    const oldShowEnergyMap = this.options.showEnergyMap;\n\n    this.options = this.validateAndApplyDefaults({\n      ...this.options,\n      ...options,\n    } as SeamOptions);\n\n    // Invalidate energy map cache if showEnergyMap option changed\n    if (this.options.showEnergyMap !== oldShowEnergyMap) {\n      this.cachedEnergyMapImageData = null;\n    }\n\n    this.queueRedraw();\n  }\n\n  private queueRedraw(): void {\n    if (this.redrawQueued) {\n      return;\n    }\n    this.redrawQueued = true;\n\n    Promise.resolve().then(async () => {\n      await this.redraw();\n      this.redrawQueued = false;\n    });\n  }\n\n  // The total number of seams to add or remove.\n  private determineCarvingParameters(imageData: ImageData): {\n    availableSeams: number;\n    interpolationPixels: number;\n    carveDown: boolean;\n  } {\n    const { carvingPriority, maxCarveUpSeamPercentage, maxCarveUpScale, maxCarveDownScale } =\n      this.options;\n    const { width: originalWidth, height: originalHeight } = imageData;\n\n    const targetAspectRatio = this.width / this.height;\n    const targetWidth = Math.round(originalHeight * targetAspectRatio);\n    const pixelDelta = originalWidth - targetWidth;\n\n    //\n    if (pixelDelta === 0) {\n      return { availableSeams: 0, interpolationPixels: 0, carveDown: false };\n    }\n\n    const seamsToCalculate = Math.abs(pixelDelta) * carvingPriority;\n    const maxRatio = pixelDelta > 0 ? maxCarveDownScale : maxCarveUpSeamPercentage;\n    const maxSeams = originalWidth * maxRatio;\n    const direction = pixelDelta > 0 ? 1 : -1;\n    const carveDown = pixelDelta > 0;\n\n    const availableSeams = Math.floor(Math.min(seamsToCalculate, maxSeams)) * direction;\n\n    // if shrinking\n    if (carveDown) {\n      return { availableSeams, interpolationPixels: 0, carveDown };\n    } else {\n      // Calculate totalPixelsToInsert based on the effective target width driven by aspect ratio and canvas dimensions,\n      // capped by maxCarveUpScale.\n      const targetEffectiveWidthByRatio = Math.round((originalHeight / this.height) * this.width);\n      const targetPixelsNeeded = targetEffectiveWidthByRatio - originalWidth;\n\n      const maxCarveUpImageDataWidth = Math.floor(originalWidth * maxCarveUpScale);\n      const maxPixelsByScale = maxCarveUpImageDataWidth - originalWidth;\n\n      // The total pixels to insert is the minimum of what's needed for the target ratio, and what's allowed by maxCarveUpScale.\n      const totalPixelsToInsert = Math.max(0, Math.min(targetPixelsNeeded, maxPixelsByScale));\n\n      const interpolationPixels = totalPixelsToInsert;\n\n      return { availableSeams: -availableSeams, interpolationPixels, carveDown };\n    }\n  }\n\n  private async getEnergyMapImageData(): Promise<ImageData> {\n    if (this.cachedEnergyMapImageData) {\n      return this.cachedEnergyMapImageData;\n    }\n\n    const originalImageData = await this.imageLoader.imageData;\n    const energyMap = new EnergyMap(originalImageData);\n    this.cachedEnergyMapImageData = energyMap.getEnergyMapAsImageData();\n\n    return this.cachedEnergyMapImageData;\n  }\n\n  private async getSourceImageData(): Promise<ImageData> {\n    if (this.options.showEnergyMap) {\n      return await this.getEnergyMapImageData();\n    } else {\n      return await this.imageLoader.imageData;\n    }\n  }\n\n  private async _redraw(): Promise<void> {\n    if (!this.width || !this.height) return;\n\n    this.profiler.start('redraw');\n    const originalImageData = await this.getSourceImageData();\n\n    const { availableSeams, interpolationPixels, carveDown } =\n      this.determineCarvingParameters(originalImageData);\n\n    let finalImageData: ImageData;\n\n    if (availableSeams === 0) {\n      finalImageData = originalImageData;\n    } else {\n      this.profiler.start('generateSeamGrid', 1);\n      const seamGrid = await this.generator.generateSeamGrid(availableSeams);\n      this.profiler.end('generateSeamGrid');\n\n      if (carveDown) {\n        finalImageData = this.filterPixels(originalImageData, seamGrid, availableSeams);\n      } else {\n        finalImageData = this.interpolatePixels(\n          originalImageData,\n          seamGrid,\n          availableSeams,\n          interpolationPixels\n        );\n      }\n    }\n\n    this.canvas.width = finalImageData.width;\n    this.canvas.height = finalImageData.height;\n    this.ctx.putImageData(finalImageData, 0, 0);\n\n    const styleRef = this.canvas.style;\n    const isVertical = this.options.scalingAxis === 'vertical';\n\n    styleRef.transformOrigin = '0 0';\n    styleRef.transform = isVertical ? 'rotate(-90deg) translateX(-100%)' : '';\n\n    styleRef.width = `${isVertical ? this.height : this.width}px`;\n    styleRef.height = `${isVertical ? this.width : this.height}px`;\n\n    this.profiler.end('redraw');\n  }\n\n  private interpolatePixels(\n    originalImageData: ImageData,\n    seamGrid: SeamPixelPriorityGrid,\n    seamsAvailable: number,\n    totalPixelsToInsert: number\n  ): ImageData {\n    const { width: originalWidth, height, data: originalData } = originalImageData;\n    const newWidth = originalWidth + totalPixelsToInsert;\n    const newSize = newWidth * height * 4;\n    const newData = new Uint8ClampedArray(newSize);\n    let writeIndex = 0;\n    const numPixels = originalData.length / 4;\n\n    const basePixelsPerLocation = Math.floor(totalPixelsToInsert / seamsAvailable);\n    const extraPixelsCount = totalPixelsToInsert % seamsAvailable;\n\n    let x = 0;\n    for (let readIndex = 0; readIndex < numPixels; readIndex++) {\n      const priority = seamGrid[readIndex]!;\n      const readIndexRgba = readIndex * 4;\n\n      // If this pixel is a seam to be \"inserted\", add an interpolated pixel first.\n      if (priority < seamsAvailable) {\n        // Determine how many pixels to interpolate for *this specific seam*\n        // To interlace the extra pixels, we distribute them based on a calculated pattern\n        // rather than front-loading them to the lowest priority indices.\n        const addExtraPixel =\n          extraPixelsCount > 0 && (priority * extraPixelsCount) % seamsAvailable < extraPixelsCount;\n\n        const pixelsToInterpolate = addExtraPixel\n          ? basePixelsPerLocation + 1\n          : basePixelsPerLocation;\n\n        if (x === 0) {\n          // First column, just duplicate the pixel\n          for (let i = 0; i < pixelsToInterpolate; i++) {\n            newData[writeIndex] = originalData[readIndexRgba]!;\n            newData[writeIndex + 1] = originalData[readIndexRgba + 1]!;\n            newData[writeIndex + 2] = originalData[readIndexRgba + 2]!;\n            newData[writeIndex + 3] = originalData[readIndexRgba + 3]!;\n            writeIndex += 4;\n          }\n        } else {\n          // Interpolate with the pixel to the left\n          const leftReadIndexRgba = (readIndex - 1) * 4;\n\n          const r0 = originalData[leftReadIndexRgba]!;\n          const g0 = originalData[leftReadIndexRgba + 1]!;\n          const b0 = originalData[leftReadIndexRgba + 2]!;\n          const a0 = originalData[leftReadIndexRgba + 3]!;\n\n          const dr = originalData[readIndexRgba]! - r0;\n          const dg = originalData[readIndexRgba + 1]! - g0;\n          const db = originalData[readIndexRgba + 2]! - b0;\n          const da = originalData[readIndexRgba + 3]! - a0;\n\n          const denominator = pixelsToInterpolate + 1;\n          for (let i = 0; i < pixelsToInterpolate; i++) {\n            // Calculate interpolation factor for the current interpolated pixel\n            const interpolationFactor = (i + 1) / denominator;\n\n            newData[writeIndex] = Math.round(r0 + dr * interpolationFactor);\n            newData[writeIndex + 1] = Math.round(g0 + dg * interpolationFactor);\n            newData[writeIndex + 2] = Math.round(b0 + db * interpolationFactor);\n            newData[writeIndex + 3] = Math.round(a0 + da * interpolationFactor);\n            writeIndex += 4;\n          }\n        }\n      }\n\n      // Always write the original pixel\n      newData[writeIndex] = originalData[readIndexRgba]!;\n      newData[writeIndex + 1] = originalData[readIndexRgba + 1]!;\n      newData[writeIndex + 2] = originalData[readIndexRgba + 2]!;\n      newData[writeIndex + 3] = originalData[readIndexRgba + 3]!;\n      writeIndex += 4;\n\n      if (++x === originalWidth) {\n        x = 0;\n      }\n    }\n\n    if (writeIndex !== newSize) {\n      console.error(\n        `[${packageName}] Mismatch during interpolation. Wrote ${writeIndex} bytes but expected ${newSize}.`\n      );\n    }\n\n    return new ImageData(newData, newWidth, height);\n  }\n\n  private filterPixels(\n    originalImageData: ImageData,\n    seamGrid: SeamPixelPriorityGrid,\n    seamsToRemove: number\n  ): ImageData {\n    const { width: originalWidth, height, data: originalData } = originalImageData;\n    const newWidth = originalWidth - seamsToRemove;\n    const newSize = newWidth * height * 4;\n    const newData = new Uint8ClampedArray(newSize);\n    const numPixels = originalData.length / 4;\n    let writeIndex = 0;\n\n    for (let readIndex = 0; readIndex < numPixels; readIndex++) {\n      const priority = seamGrid[readIndex]!;\n\n      if (priority >= seamsToRemove) {\n        const readIndexRgba = readIndex * 4;\n\n        newData[writeIndex] = originalData[readIndexRgba]!;\n        newData[writeIndex + 1] = originalData[readIndexRgba + 1]!;\n        newData[writeIndex + 2] = originalData[readIndexRgba + 2]!;\n        newData[writeIndex + 3] = originalData[readIndexRgba + 3]!;\n\n        writeIndex += 4;\n      }\n    }\n\n    if (writeIndex !== newSize) {\n      console.error(\n        `[${packageName}] Mismatch in pixel buffer size. Expected ${newSize}, but got ${writeIndex}.`\n      );\n    }\n\n    return new ImageData(newData, newWidth, height);\n  }\n\n  private handleFailure(error: unknown): void {\n    if (this.hasFailed) return;\n\n    this.hasFailed = true;\n\n    console.error(`[${packageName}] A critical error occurred. Falling back to <img>.`, error);\n\n    this.canvas?.remove();\n\n    const img = document.createElement('img');\n\n    img.src = this.src;\n    img.style.width = '100%';\n    img.style.height = '100%';\n    img.style.display = 'block';\n\n    this.parentNode.appendChild(img);\n  }\n}\n", "import { Renderer, RendererConfig } from '../renderer/renderer';\nimport { ScalingAxis } from '../../utils/enums/enums';\nimport { toKebabCase } from '../../utils/to-kebab-case/to-kebab-case';\n\ntype SeamAttributes = Omit<RendererConfig, 'parentNode' | 'src' | 'width' | 'height' | 'logger'>;\n\nexport class FluidImg extends HTMLElement {\n  private renderer: Renderer | null = null;\n  private resizeObserver: ResizeObserver | null = null;\n  private intersectionObserver: IntersectionObserver | null = null;\n  private updateQueue = new Set<string>();\n  private isIntersecting = false;\n  private storedDimensions: { width: number; height: number } | null = null;\n  private options: Record<string, string | number | boolean> = {};\n\n  constructor() {\n    super();\n  }\n\n  static get observedAttributes(): Array<\n    keyof SeamAttributes | 'src' | 'mask' | 'on-screen-threshold'\n  > {\n    const seamAttributes: Array<keyof SeamAttributes> = [\n      'generator',\n      'carvingPriority',\n      'maxCarveUpSeamPercentage',\n      'maxCarveUpScale',\n      'maxCarveDownScale',\n      'scalingAxis',\n      'showEnergyMap',\n      'mask',\n    ];\n\n    const kebabCaseAttributes = seamAttributes.map(toKebabCase);\n\n    return ['src', 'mask', 'on-screen-threshold', ...kebabCaseAttributes] as any;\n  }\n\n  connectedCallback(): void {\n    this.setupResizeObserver();\n    this.setupIntersectionObserver();\n  }\n\n  disconnectedCallback(): void {\n    this.renderer?.destroy();\n    this.renderer = null;\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = null;\n    this.intersectionObserver?.disconnect();\n    this.intersectionObserver = null;\n  }\n\n  attributeChangedCallback(name: string, oldValue: string | null, newValue: string | null): void {\n    if (oldValue === newValue) return;\n\n    if (!this.updateQueue.size) {\n      setTimeout(this.processUpdates);\n    }\n\n    this.updateQueue.add(name);\n  }\n\n  private processUpdates = (): void => {\n    const changes = Array.from(this.updateQueue);\n    this.updateQueue.clear();\n\n    if (changes.includes('src') || changes.includes('scaling-axis') || changes.includes('mask')) {\n      this.renderer?.destroy();\n      this.renderer = null;\n      this.initializeRenderer();\n      return;\n    }\n\n    if (changes.includes('on-screen-threshold')) {\n      this.setupIntersectionObserver();\n    }\n\n    if (!this.renderer) return;\n\n    const otherOptions = changes.reduce(\n      (acc, key) => {\n        if (key !== 'src' && key !== 'on-screen-threshold') {\n          const value = this.getAttribute(key);\n          acc[key] = value;\n        }\n        return acc;\n      },\n      {} as Record<string, string | null>\n    );\n\n    this.renderer.setOptions(otherOptions);\n  };\n\n  private dispatchLogEvent = (message: string): void => {\n    const event = new CustomEvent('log', {\n      detail: { message },\n      bubbles: true,\n      composed: true,\n    });\n    this.dispatchEvent(event);\n  };\n\n  private initializeRenderer(): void {\n    if (this.renderer) {\n      return;\n    }\n\n    const options = this.getOptions();\n    this.renderer = new Renderer({\n      parentNode: this,\n      logger: this.dispatchLogEvent,\n      ...options,\n    });\n  }\n\n  private calculateDimensions() {\n    const width = this.clientWidth ?? 100;\n    const height = this.clientHeight ?? 100;\n\n    return { width, height };\n  }\n\n  private getOptions(): any {\n    const options: Record<string, any> = {};\n    for (const attr of FluidImg.observedAttributes) {\n      const kebabCaseAttr = toKebabCase(attr);\n      if (this.hasAttribute(kebabCaseAttr)) {\n        const value = this.getAttribute(kebabCaseAttr);\n        options[attr] = { '': true, true: true, false: false }[value + ''] ?? value;\n      }\n    }\n    return options;\n  }\n\n  private setupResizeObserver(): void {\n    if (!this.parentElement) return;\n\n    this.resizeObserver = new ResizeObserver(() => {\n      const dimensions = this.calculateDimensions();\n\n      this.storedDimensions = dimensions;\n      this.attemptSetSize();\n    });\n\n    this.resizeObserver.observe(this);\n  }\n\n  private setupIntersectionObserver(): void {\n    this.intersectionObserver?.disconnect();\n\n    const threshold = this.getAttribute('on-screen-threshold') || '50px';\n    this.intersectionObserver = new IntersectionObserver(\n      (entries) => {\n        for (const entry of entries) {\n          this.isIntersecting = entry.isIntersecting;\n          if (this.isIntersecting) {\n            this.attemptSetSize();\n          }\n        }\n      },\n      {\n        rootMargin: `${threshold} ${threshold} ${threshold} ${threshold}`,\n      }\n    );\n\n    this.intersectionObserver.observe(this);\n  }\n\n  private attemptSetSize(): void {\n    if (!this.isIntersecting || !this.storedDimensions) return;\n\n    this.renderer?.setSize(this.storedDimensions.width, this.storedDimensions.height);\n    this.storedDimensions = null;\n  }\n\n  get maxCarveUpScale(): number {\n    return this.options['max-carve-up-scale'] as number;\n  }\n  set maxCarveUpScale(value: number) {\n    this.options['max-carve-up-scale'] = value;\n    this.renderer?.setOptions({ maxCarveUpScale: value });\n  }\n\n  get scalingAxis(): ScalingAxis {\n    return this.options['scaling-axis'] as ScalingAxis;\n  }\n  set scalingAxis(value: ScalingAxis) {\n    this.options['scaling-axis'] = value;\n    this.renderer?.setOptions({ scalingAxis: value });\n  }\n\n  get showEnergyMap(): boolean {\n    return this.options['show-energy-map'] as boolean;\n  }\n  set showEnergyMap(value: boolean) {\n    this.options['show-energy-map'] = value;\n    this.renderer?.setOptions({ showEnergyMap: value });\n  }\n\n  get onScreenThreshold(): number {\n    const threshold = this.getAttribute('on-screen-threshold') || '50px';\n    return parseInt(threshold.replace('px', ''), 10);\n  }\n}\n\ncustomElements.define('fluid-img', FluidImg);\n"],
  "mappings": "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",
  "names": ["EvenWidthImage", "#rotate", "options", "originalWidth", "ImageLoader", "#src", "#imgPromise", "#imageDataPromise", "#profiler", "src", "#loadImage", "img", "#loadImageData", "resolve", "reject", "image", "profiler", "context", "imageData", "deterministicBinaryRnd", "seed1", "seed2", "h", "deleteArrayIndices", "array", "uniqueSortedIndicesToRemove", "elementsPerRemoval", "newSize", "ArrayConstructor", "result", "resultOffset", "sourceStart", "lastIndex", "deleteIndex", "chunkSize", "getGrayscaleImageData", "imageData", "asRows", "useLinearApproximation", "data", "width", "height", "grayscaleData", "y", "rowOffset", "currentArray", "x", "ix", "r", "g", "b", "a", "gray", "SobelEnergyMap", "#data", "#width", "#height", "#grayscaleMap", "#originalIndices", "#maskData", "imageData", "maskData", "getGrayscaleImageData", "#fillOriginalIndices", "#computeFullEnergyMap", "#getMaskEnergy", "y", "x", "originalIndex", "width", "height", "energyMapData", "y1", "y3", "prevRow", "currentRow", "nextRow", "x1", "x3", "gx", "gy", "sobelEnergy", "maskEnergy", "xIndices", "xToRemove", "deleteArrayIndices", "g", "colInNewCoord", "removedOriginalIndex", "removedColOrigIdx", "columnsInNewDataToUpdate", "xCurrent", "xCenter", "seams", "numSeamsToRemove", "indicesToRemoveForRow", "seamPath", "a", "b", "minEnergy", "maxEnergy", "energy", "energyRange", "data", "index", "normalizedEnergy", "getPixelIndex", "x", "y", "width", "getGrayscale", "data", "getColorDistance", "x1", "y1", "x2", "y2", "i1", "i2", "dr", "dg", "db", "DualEnergyMap", "#data", "#width", "#height", "#grayscaleMap", "#originalIndices", "#imageData", "#forwardEnergyWeight", "imageData", "forwardEnergyWeight", "maskData", "#fillOriginalIndices", "#computeGrayscaleMap", "#computeFullEnergyMap", "#computeBackwardEnergy", "y3", "x3", "prevRow", "currentRow", "nextRow", "gx", "gy", "#computeForwardEnergy", "leftX", "rightX", "horizontalCost", "topY", "bottomY", "verticalCost", "diagonalCost", "height", "energyMapData", "backwardEnergy", "forwardEnergy", "totalEnergy", "xIndices", "xToRemove", "deleteArrayIndices", "newImageData", "writeIndex", "seamX", "readIndex", "g", "colInNewCoord", "removedOriginalIndex", "removedColOrigIdx", "columnsInNewDataToUpdate", "xCurrent", "seams", "numSeamsToRemove", "indicesToRemoveForRow", "seamPath", "b", "indicesToRemove", "a", "removeIndex", "minEnergy", "maxEnergy", "energy", "energyRange", "index", "normalizedEnergy", "getPixelIndex", "x", "y", "width", "getGrayscale", "data", "getColorDistance", "x1", "y1", "x2", "y2", "i1", "i2", "dr", "dg", "db", "getRegionVariance", "centerX", "centerY", "radius", "sum", "sumSquares", "count", "dy", "dx", "gray", "mean", "variance", "BoundaryAwareEnergyMap", "#data", "#width", "#height", "#grayscaleMap", "#originalIndices", "#imageData", "#boundaryPenaltyWeight", "#uniformityThreshold", "#edgeThreshold", "imageData", "boundaryPenaltyWeight", "uniformityThreshold", "edgeThreshold", "maskData", "#fillOriginalIndices", "#computeGrayscaleMap", "#computeFullEnergyMap", "#computeGradientEnergy", "y3", "x3", "prevRow", "currentRow", "nextRow", "gx", "gy", "#computeForwardEnergy", "leftX", "rightX", "horizontalCost", "topY", "bottomY", "verticalCost", "#detectBoundaryPenalty", "gradientEnergy", "leftVariance", "rightVariance", "topVariance", "bottomVariance", "boundaryStrength", "minVariance", "uniformityFactor", "horizontalDiff", "verticalDiff", "maxTextureDiff", "textureFactor", "strongEdgeFactor", "edgeFactor", "height", "energyMapData", "forwardEnergy", "boundaryPenalty", "totalEnergy", "xIndices", "xToRemove", "deleteArrayIndices", "newImageData", "writeIndex", "seamX", "readIndex", "removedColOrigIdx", "columnsInNewDataToUpdate", "xCurrent", "seams", "numSeamsToRemove", "indicesToRemoveForRow", "seamPath", "b", "indicesToRemove", "a", "removeIndex", "minEnergy", "maxEnergy", "energy", "energyRange", "index", "normalizedEnergy", "ENERGY_ALGORITHM", "CONFIG", "createEnergyMap", "algorithm", "imageData", "maskData", "SobelEnergyMap", "DualEnergyMap", "BoundaryAwareEnergyMap", "_exhaustive", "EnergyMap", "xIndices", "seams", "width", "height", "BaseGenerator", "options", "imageData", "maskData", "EnergyMap", "getGrayscaleImageData", "minSeams", "width", "defaultOptions", "RandomGenerator", "BaseGenerator", "options", "percentage", "energyMap", "originalIndices", "currentWidth", "currentHeight", "seams", "_", "ix", "a", "b", "batchSize", "batchSeams", "seamIndex", "i", "x", "y", "originalIndex", "seam", "width", "height", "rndGenerator", "deterministicBinaryRnd", "lastColIx", "energyMapData", "energy", "lastX", "getGenerator", "options", "specificType", "RandomGenerator", "createGenerator", "generator", "Profiler", "#log", "#times", "#activeStack", "log", "name", "minLoggingTime", "startTime", "totalNestedTime", "elapsedTime", "stackSize", "parentName", "parentData", "errorBoundary", "originalMethod", "args", "result", "error", "toKebabCase", "str", "name", "createOptionGetters", "options", "_name", "defaultValue", "min", "max", "name", "value", "toKebabCase", "enumObject", "ScalingAxis", "Renderer", "errorBoundary", "config", "parentNode", "src", "mask", "options", "rotate", "Profiler", "ImageLoader", "e", "createGenerator", "getBoolean", "getConstrainedNumber", "getEnumValue", "createOptionGetters", "ScalingAxis", "width", "height", "parentNodeSize", "oldShowEnergyMap", "imageData", "carvingPriority", "maxCarveUpSeamPercentage", "maxCarveUpScale", "maxCarveDownScale", "originalWidth", "originalHeight", "targetAspectRatio", "targetWidth", "pixelDelta", "seamsToCalculate", "maxRatio", "maxSeams", "direction", "carveDown", "availableSeams", "targetPixelsNeeded", "maxPixelsByScale", "interpolationPixels", "originalImageData", "energyMap", "EnergyMap", "finalImageData", "seamGrid", "styleRef", "isVertical", "seamsAvailable", "totalPixelsToInsert", "originalData", "newWidth", "newSize", "newData", "writeIndex", "numPixels", "basePixelsPerLocation", "extraPixelsCount", "x", "readIndex", "priority", "readIndexRgba", "pixelsToInterpolate", "i", "leftReadIndexRgba", "r0", "g0", "b0", "a0", "dr", "dg", "db", "da", "denominator", "interpolationFactor", "name", "seamsToRemove", "error", "img", "FluidImg", "_FluidImg", "toKebabCase", "name", "oldValue", "newValue", "changes", "otherOptions", "acc", "key", "value", "message", "event", "options", "Renderer", "width", "height", "attr", "kebabCaseAttr", "dimensions", "threshold", "entries", "entry"]
}
