{
  "version": 3,
  "sources": ["../src/utils/image-loader/image-loader.ts", "../package.json", "../src/utils/deterministic-binary-rnd/deterministic-binary-rnd.ts", "../src/utils/delete-array-indicies/delete-array-indicies.ts", "../src/generator/grayscale/grayscale.ts", "../src/generator/sobel-energy-map/sobel-energy-map.ts", "../src/generator/energy-map-registry/energy-map-registry.ts", "../src/generator/energy-map/energy-map.ts", "../src/generator/base-generator/base-generator.ts", "../src/generator/random-generator/random-generator.ts", "../src/generator/generator/generator.ts", "../src/utils/profiler/profiler.ts", "../src/utils/error-boundary/error-boundary.ts", "../src/utils/to-kebab-case/to-kebab-case.ts", "../src/utils/option-helpers/option-helpers.ts", "../src/utils/enums/enums.ts", "../src/renderer/renderer/renderer.ts", "../src/renderer/web-component/web-component.ts"],
  "sourcesContent": ["import { Profiler } from '../../utils/profiler/profiler';\n\nclass EvenWidthImage extends Image {\n  #rotate: boolean;\n\n  constructor(options: { rotate?: boolean } = {}) {\n    super();\n    this.crossOrigin = `Anonymous`;\n    this.#rotate = !!options.rotate;\n  }\n\n  override get width(): number {\n    const originalWidth = this.#rotate ? super.height : super.width;\n    return originalWidth - (originalWidth % 2);\n  }\n\n  override get height(): number {\n    return this.#rotate ? super.width : super.height;\n  }\n}\n\nexport class ImageLoader {\n  #src: string;\n  #imgPromise: Promise<HTMLImageElement>;\n  #imageDataPromise: Promise<ImageData>;\n  #rotate: boolean;\n  #profiler?: Profiler;\n\n  constructor(src: string, options: { rotate: boolean; profiler?: Profiler }) {\n    this.#src = src;\n    this.#rotate = options.rotate;\n    this.#profiler = options.profiler;\n    this.#imgPromise = this.#loadImage();\n    this.#imageDataPromise = this.#imgPromise.then((img) => this.#loadImageData(img));\n  }\n\n  #loadImage(): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n      const src = this.#src;\n      const img = new EvenWidthImage({ rotate: this.#rotate });\n      img.onload = () => resolve(img);\n      img.onerror = () => reject(`Failed to load image: ${src}`);\n      img.onabort = () => reject(`Image loading aborted: ${src}`);\n      img.src = src;\n    });\n  }\n\n  #loadImageData(image: HTMLImageElement): Promise<ImageData> {\n    const profiler = this.#profiler;\n\n    return new Promise((resolve) => {\n      profiler?.start('loadImageData');\n      const canvas = new OffscreenCanvas(image.width, image.height);\n      const context = canvas.getContext('2d')!;\n\n      if (this.#rotate) {\n        context.translate(image.width, 0);\n        context.rotate(Math.PI / 2);\n      }\n\n      context.drawImage(image, 0, 0);\n\n      const imageData = context.getImageData(0, 0, image.width, image.height);\n\n      profiler?.end('loadImageData');\n\n      resolve(imageData);\n    });\n  }\n\n  get src(): string {\n    return this.#src;\n  }\n\n  get image(): Promise<HTMLImageElement> {\n    return this.#imgPromise;\n  }\n\n  get imageData(): Promise<ImageData> {\n    return this.#imageDataPromise;\n  }\n}\n", "{\n  \"name\": \"fluid-img\",\n  \"version\": \"0.2.0\",\n  \"description\": \"A web component for displaying images that intelligently resize to fit most any container.\",\n  \"author\": \"Voice NPO, Inc.\",\n  \"license\": \"Fluid-Img Revenue-Limited License\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/VoiceNGO/fluid-img.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/VoiceNGO/fluid-img/issues\"\n  },\n  \"homepage\": \"https://voicengo.github.io/fluid-img/public/fluid-demo.html\",\n  \"type\": \"module\",\n  \"main\": \"./dist/fluid-img.js\",\n  \"module\": \"./dist/fluid-img.js\",\n  \"types\": \"./dist/fluid-img.d.ts\",\n  \"files\": [\n    \"dist\",\n    \"src\",\n    \"README.md\"\n  ],\n  \"exports\": {\n    \".\": \"./dist/fluid-img.js\",\n    \"./random\": \"./dist/fluid-img-random.js\",\n    \"./predictive\": \"./dist/fluid-img-predictive.js\"\n  },\n  \"scripts\": {\n    \"test\": \"vitest -t \\\"^[^@]+$\\\"\",\n    \"test:live\": \"vitest -t \\\"@LIVE\\\"\",\n    \"test:watch\": \"vitest watch\",\n    \"build\": \"npm run build:all && npm run build:random && npm run build:predictive && npm run build:demo && npm run copy-to-docs\",\n    \"watch\": \"npm run watch:all & npm run watch:random & npm run watch:predictive & npm run watch:demo\",\n    \"build:all\": \"node scripts/build.js --RANDOM_GENERATOR=true --PREDICTIVE_GENERATOR=true --outfile=dist/fluid-img.js\",\n    \"build:random\": \"node scripts/build.js --RANDOM_GENERATOR=true --outfile=dist/fluid-img-random.js\",\n    \"build:predictive\": \"node scripts/build.js --PREDICTIVE_GENERATOR=true --outfile=dist/fluid-img-predictive.js\",\n    \"build:demo\": \"node scripts/build.js --RANDOM_GENERATOR=true --PREDICTIVE_GENERATOR=true --DEMO=true --outfile=dist/fluid-img-demo.js\",\n    \"watch:all\": \"npm run build:all -- --watch\",\n    \"watch:random\": \"npm run build:random -- --watch\",\n    \"watch:predictive\": \"npm run build:predictive -- --watch\",\n    \"watch:demo\": \"npm run build:demo -- --watch\",\n    \"copy-to-docs\": \"cp ./dist/* ./docs/public/.\"\n  },\n  \"devDependencies\": {\n    \"esbuild\": \"^0.25.4\",\n    \"eslint\": \"^9.27.0\",\n    \"prettier\": \"^3.5.3\",\n    \"type-fest\": \"^4.41.0\",\n    \"typescript\": \"^5.8.3\",\n    \"vitest\": \"^3.1.4\",\n    \"@types/node\": \"^22.15.21\"\n  }\n}\n", "export const deterministicBinaryRnd =\n  (seed1: number) =>\n  (seed2: number): number => {\n    let h = seed1 ^ seed2;\n    h ^= h >>> 16;\n    h *= 0x85ebca6b;\n    h ^= h >>> 13;\n    h *= 0xc2b2ae35;\n    h ^= h >>> 16;\n    return h & 1;\n  };\n", "import type { TypedArray, Constructor } from 'type-fest';\n\nexport function deleteArrayIndices<T extends TypedArray>(\n  array: T,\n  uniqueSortedIndicesToRemove: number[],\n  elementsPerRemoval: number = 1\n): T {\n  const newSize = array.length - uniqueSortedIndicesToRemove.length * elementsPerRemoval;\n  const ArrayConstructor = array.constructor as Constructor<T>;\n  const result = new ArrayConstructor(newSize) as T;\n\n  let resultOffset = 0;\n  let sourceStart = 0;\n  let lastIndex = -1;\n\n  for (const deleteIndex of uniqueSortedIndicesToRemove) {\n    if (lastIndex === deleteIndex) {\n      throw new Error('[deleteArrayIndices]: Duplicate index detected');\n    }\n    if (lastIndex > deleteIndex) {\n      throw new Error('[deleteArrayIndices]: Indices are not sorted');\n    }\n\n    const chunkSize = deleteIndex - sourceStart;\n\n    if (chunkSize > 0) {\n      (result as any).set(array.subarray(sourceStart, deleteIndex), resultOffset);\n      resultOffset += chunkSize;\n    }\n\n    sourceStart = deleteIndex + elementsPerRemoval;\n    lastIndex = deleteIndex;\n  }\n\n  if (sourceStart < array.length) {\n    (result as any).set(array.subarray(sourceStart), resultOffset);\n  }\n\n  return result;\n}\n", "import { GrayscalePixelArray } from '../../utils/types/types';\n\nexport function getGrayscaleImageData<AsRows extends boolean>(\n  imageData: ImageData,\n  asRows: AsRows,\n  useLinearApproximation = false\n): AsRows extends true ? Uint8Array[] : GrayscalePixelArray {\n  const { data, width, height } = imageData;\n  const grayscaleData = asRows ? new Array(height) : new Uint8Array(width * height);\n\n  for (let y = 0; y < height; y++) {\n    const rowOffset = y * width;\n    const currentArray = asRows ? (grayscaleData[y] = new Uint8Array(width)) : grayscaleData;\n\n    for (let x = 0; x < width; x++) {\n      const ix = (rowOffset + x) * 4;\n      const r = data[ix];\n      const g = data[ix + 1];\n      const b = data[ix + 2];\n      const a = data[ix + 3];\n\n      let gray;\n      if (useLinearApproximation) {\n        gray = (((r! + g! + b!) / 3) * a!) / 255;\n      } else {\n        gray = ((0.299 * r! + 0.587 * g! + 0.114 * b!) * a!) / 255;\n      }\n\n      currentArray[asRows ? x : rowOffset + x] = gray;\n    }\n  }\n\n  return grayscaleData as any;\n}\n", "// TODO: Test Sobel energy calculation using sqrt(Gx^2 + Gy^2) and adjust normalization for comparison.\n// Current method uses abs(Gx) + abs(Gy).\nimport type { Tagged } from 'type-fest';\nimport { deleteArrayIndices } from '../../utils/delete-array-indicies/delete-array-indicies';\nimport { getGrayscaleImageData } from '../grayscale/grayscale';\nimport { GrayscalePixelArray } from '../../utils/types/types';\nimport {\n  registerEnergyMap,\n  SobelEnergyMapOptions,\n} from '../energy-map-registry/energy-map-registry';\n\ntype EnergyMapData = Tagged<Uint16Array, 'energyMapData'>;\ntype EnergyMapIndices = Tagged<Uint32Array, 'energyMapIndices'>;\n\nexport class SobelEnergyMap {\n  #data: EnergyMapData[];\n  #width: number;\n  #height: number;\n  #grayscaleMap: Uint8Array[];\n  #originalIndices: EnergyMapIndices[];\n  #maskData?: GrayscalePixelArray;\n\n  constructor(options: SobelEnergyMapOptions) {\n    this.#width = options.imageData.width;\n    this.#height = options.imageData.height;\n    this.#data = new Array(this.#height);\n    this.#originalIndices = new Array(this.#height);\n    this.#maskData = options.maskData;\n\n    this.#grayscaleMap = getGrayscaleImageData(options.imageData, true);\n    this.#fillOriginalIndices();\n    this.#data = this.#computeFullEnergyMap();\n  }\n\n  #getMaskEnergy(y: number, x: number): number {\n    if (!this.#maskData) {\n      return 255;\n    }\n    const originalIndex = this.#originalIndices[y]![x]!;\n    return this.#maskData[originalIndex]!;\n  }\n\n  #fillOriginalIndices(): void {\n    for (let y = 0; y < this.#height; y++) {\n      this.#originalIndices[y] = new Uint32Array(this.#width) as EnergyMapIndices;\n      for (let x = 0; x < this.#width; x++) {\n        this.#originalIndices[y]![x] = y * this.#width + x;\n      }\n    }\n  }\n\n  #computeFullEnergyMap(\n    width: number = this.#width,\n    height: number = this.#height\n  ): EnergyMapData[] {\n    const energyMapData: EnergyMapData[] = new Array(height);\n\n    for (let y = 0; y < height; y++) {\n      energyMapData[y] = new Uint16Array(width) as EnergyMapData;\n\n      const y1 = Math.max(0, y - 1);\n      const y3 = Math.min(height - 1, y + 1);\n      const prevRow = this.#grayscaleMap[y1]!;\n      const currentRow = this.#grayscaleMap[y]!;\n      const nextRow = this.#grayscaleMap[y3]!;\n\n      for (let x = 0; x < width; x++) {\n        const x1 = Math.max(0, x - 1);\n        const x3 = Math.min(width - 1, x + 1);\n\n        const gx =\n          -prevRow[x1]! +\n          prevRow[x3]! +\n          -currentRow[x1]! * 2 +\n          currentRow[x3]! * 2 +\n          -nextRow[x1]! +\n          nextRow[x3]!;\n\n        const gy =\n          -prevRow[x1]! +\n          -prevRow[x]! * 2 +\n          -prevRow[x3]! +\n          nextRow[x1]! +\n          nextRow[x]! * 2 +\n          nextRow[x3]!;\n\n        const sobelEnergy = (gx < 0 ? -gx : gx) + (gy < 0 ? -gy : gy);\n        const maskEnergy = this.#getMaskEnergy(y, x);\n        energyMapData[y]![x] = sobelEnergy * (maskEnergy / 255);\n      }\n    }\n\n    return energyMapData;\n  }\n\n  get width(): number {\n    return this.#width;\n  }\n\n  get height(): number {\n    return this.#height;\n  }\n\n  get energyMap(): readonly EnergyMapData[] {\n    return this.#data;\n  }\n\n  get originalIndices(): readonly EnergyMapIndices[] {\n    return this.#originalIndices;\n  }\n\n  removeSeam(xIndices: Uint16Array): void {\n    for (let y = 0; y < this.#height; y++) {\n      const xToRemove = xIndices[y]!;\n      this.#data[y] = deleteArrayIndices(this.#data[y]!, [xToRemove]);\n      this.#originalIndices[y] = deleteArrayIndices(this.#originalIndices[y]!, [xToRemove]);\n    }\n    this.#width--;\n\n    const g = (colInNewCoord: number, removedOriginalIndex: number) =>\n      colInNewCoord < removedOriginalIndex ? colInNewCoord : colInNewCoord + 1;\n\n    for (let y = 0; y < this.#height; y++) {\n      const removedColOrigIdx = xIndices[y]!;\n\n      // Cache row references with clamping\n      const y1 = Math.max(0, y - 1);\n      const y3 = Math.min(this.#height - 1, y + 1);\n      const prevRow = this.#grayscaleMap[y1]!;\n      const currentRow = this.#grayscaleMap[y]!;\n      const nextRow = this.#grayscaleMap[y3]!;\n\n      const columnsInNewDataToUpdate: number[] = [];\n      if (removedColOrigIdx > 0) {\n        columnsInNewDataToUpdate.push(removedColOrigIdx - 1);\n      }\n      if (removedColOrigIdx < this.#width) {\n        columnsInNewDataToUpdate.push(removedColOrigIdx);\n      }\n\n      for (const xCurrent of columnsInNewDataToUpdate) {\n        const x1 = Math.max(0, g(xCurrent - 1, removedColOrigIdx));\n        const x3 = Math.min(this.#grayscaleMap[0]!.length - 1, g(xCurrent + 1, removedColOrigIdx));\n        const xCenter = g(xCurrent, removedColOrigIdx);\n\n        const gx =\n          -prevRow[x1]! +\n          prevRow[x3]! +\n          -currentRow[x1]! * 2 +\n          currentRow[x3]! * 2 +\n          -nextRow[x1]! +\n          nextRow[x3]!;\n\n        const gy =\n          -prevRow[x1]! +\n          -prevRow[xCenter]! * 2 +\n          -prevRow[x3]! +\n          nextRow[x1]! +\n          nextRow[xCenter]! * 2 +\n          nextRow[x3]!;\n\n        const sobelEnergy = (gx < 0 ? -gx : gx) + (gy < 0 ? -gy : gy);\n        const maskEnergy = this.#getMaskEnergy(y, xCurrent);\n        this.#data[y]![xCurrent] = sobelEnergy + maskEnergy;\n      }\n    }\n  }\n\n  removeSeams(seams: Uint16Array[]): void {\n    if (seams.length === 0) {\n      return;\n    }\n\n    const numSeamsToRemove = seams.length;\n\n    for (let y = 0; y < this.#height; y++) {\n      const indicesToRemoveForRow: number[] = seams\n        .map((seamPath) => seamPath[y]!)\n        .sort((a, b) => a - b);\n\n      this.#data[y] = deleteArrayIndices(this.#data[y]!, indicesToRemoveForRow);\n      this.#grayscaleMap[y] = deleteArrayIndices(this.#grayscaleMap[y]!, indicesToRemoveForRow);\n      this.#originalIndices[y] = deleteArrayIndices(\n        this.#originalIndices[y]!,\n        indicesToRemoveForRow\n      );\n    }\n\n    this.#width -= numSeamsToRemove;\n\n    this.#data = this.#computeFullEnergyMap();\n  }\n\n  getEnergyMapAsImageData(width: number = this.#width, height: number = this.#height): ImageData {\n    const energyMapData = this.#computeFullEnergyMap(width, height);\n\n    // Find min and max energy values for normalization\n    let minEnergy = Infinity;\n    let maxEnergy = 0;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const energy = energyMapData[y]![x]!;\n        if (energy < minEnergy) minEnergy = energy;\n        if (energy > maxEnergy) maxEnergy = energy;\n      }\n    }\n\n    const energyRange = maxEnergy - minEnergy;\n    const imageData = new ImageData(width, height);\n    const data = imageData.data;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const index = (y * width + x) * 4;\n        const energy = energyMapData[y]![x]!;\n\n        // Normalize energy to 0-255 range\n        const normalizedEnergy =\n          energyRange > 0 ? Math.round(((energy - minEnergy) / energyRange) * 255) : 0;\n\n        // Set RGB channels to the same value for grayscale\n        data[index] = normalizedEnergy; // R\n        data[index + 1] = normalizedEnergy; // G\n        data[index + 2] = normalizedEnergy; // B\n        data[index + 3] = 255; // A (100% alpha)\n      }\n    }\n\n    return imageData;\n  }\n}\n\nif (typeof SOBEL_ENERGY_MAP !== 'undefined' && SOBEL_ENERGY_MAP) {\n  registerEnergyMap('sobel', SobelEnergyMap);\n}\n", "import { BoundaryAwareEnergyMap } from '../boundary-aware-energy-map/boundary-aware-energy-map';\nimport { DualEnergyMap } from '../dual-energy-map/dual-energy-map';\nimport { SobelEnergyMap } from '../sobel-energy-map/sobel-energy-map';\nimport { GrayscalePixelArray } from '../../utils/types/types';\nimport { name as packageName } from '../../../package.json';\n\nexport type EnergyMapAlgorithm = 'sobel' | 'dual' | 'boundary-aware';\nexport type EnergyMapImpl = SobelEnergyMap | DualEnergyMap | BoundaryAwareEnergyMap;\n\n//#region Options Types\ntype BaseEnergyMapOptions = {\n  imageData: ImageData;\n  maskData?: GrayscalePixelArray;\n};\n\nexport type SobelEnergyMapOptions = BaseEnergyMapOptions & {\n  algorithm?: 'sobel';\n};\n\nexport type DualEnergyMapOptions = BaseEnergyMapOptions & {\n  algorithm: 'dual';\n  forwardEnergyWeight?: number;\n};\n\nexport type BoundaryAwareEnergyMapOptions = BaseEnergyMapOptions & {\n  algorithm: 'boundary-aware';\n  boundaryPenaltyWeight?: number;\n  uniformityThreshold?: number;\n  edgeThreshold?: number;\n};\n\nexport type EnergyMapOptions =\n  | SobelEnergyMapOptions\n  | DualEnergyMapOptions\n  | BoundaryAwareEnergyMapOptions;\n\nconst energyMapRegistry = new Map<EnergyMapAlgorithm, new (options: any) => EnergyMapImpl>();\n\nexport function registerEnergyMap(\n  algorithm: EnergyMapAlgorithm,\n  constructor: new (options: any) => EnergyMapImpl\n) {\n  Promise.resolve().then(() => {\n    energyMapRegistry.set(algorithm, constructor);\n  });\n}\n\nexport function createEnergyMap(options: EnergyMapOptions) {\n  const algorithm = options.algorithm ?? 'sobel';\n  const EnergyMapConstructor = energyMapRegistry.get(algorithm);\n\n  if (!EnergyMapConstructor) {\n    throw new Error(\n      `[${packageName}] Energy map algorithm '${algorithm}' is not registered or included in the build.`\n    );\n  }\n\n  return new EnergyMapConstructor(options);\n}\n\n// These will self-register\nimport '../sobel-energy-map/sobel-energy-map';\nimport '../dual-energy-map/dual-energy-map';\nimport '../boundary-aware-energy-map/boundary-aware-energy-map';\n", "import { GrayscalePixelArray } from '../../utils/types/types';\nimport {\n  createEnergyMap,\n  EnergyMapAlgorithm,\n  EnergyMapImpl,\n  EnergyMapOptions,\n} from '../energy-map-registry/energy-map-registry';\nimport { BoundaryAwareEnergyMap } from '../boundary-aware-energy-map/boundary-aware-energy-map';\nimport { DualEnergyMap } from '../dual-energy-map/dual-energy-map';\nimport { SobelEnergyMap } from '../sobel-energy-map/sobel-energy-map';\n\nexport const EnergyMap = class EnergyMap {\n  private impl: EnergyMapImpl;\n\n  constructor(options: EnergyMapOptions) {\n    this.impl = createEnergyMap(options);\n  }\n\n  get width() {\n    return this.impl.width;\n  }\n\n  get height() {\n    return this.impl.height;\n  }\n\n  get energyMap() {\n    return this.impl.energyMap;\n  }\n\n  get originalIndices() {\n    return this.impl.originalIndices;\n  }\n\n  removeSeam(xIndices: Uint16Array) {\n    return this.impl.removeSeam(xIndices);\n  }\n\n  removeSeams(seams: Uint16Array[]) {\n    return this.impl.removeSeams(seams);\n  }\n\n  getEnergyMapAsImageData(width?: number, height?: number) {\n    return this.impl.getEnergyMapAsImageData(width, height);\n  }\n};\n\nexport type EnergyMap = InstanceType<typeof EnergyMap>;\n\nexport {\n  SobelEnergyMap,\n  DualEnergyMap,\n  BoundaryAwareEnergyMap,\n  createEnergyMap as createEnergyMapFactory,\n};\nexport type { EnergyMapAlgorithm };\n", "import { EnergyMap } from '../energy-map/energy-map';\nimport { ImageLoader } from '../../utils/image-loader/image-loader';\nimport { GrayscalePixelArray, SeamGenerator, SeamPixelPriorityGrid } from '../../utils/types/types';\nimport { getGrayscaleImageData } from '../grayscale/grayscale';\n\nexport type BaseGeneratorOptions = {\n  imageLoader: ImageLoader;\n  maskLoader?: ImageLoader;\n};\n\nexport abstract class BaseGenerator implements SeamGenerator {\n  protected imageLoader: ImageLoader;\n  protected maskLoader?: ImageLoader;\n  protected energyMapPromise: Promise<EnergyMap>;\n  protected seamGrid: SeamPixelPriorityGrid = new Uint16Array() as SeamPixelPriorityGrid;\n  protected generatedSeams = 0;\n\n  constructor(options: BaseGeneratorOptions) {\n    this.imageLoader = options.imageLoader;\n    this.maskLoader = options.maskLoader;\n    this.energyMapPromise = this.createEnergyMap();\n  }\n\n  async getImageData(): Promise<ImageData> {\n    return this.imageLoader.imageData;\n  }\n\n  async getImage(): Promise<HTMLImageElement> {\n    return this.imageLoader.image;\n  }\n\n  protected async createEnergyMap(): Promise<EnergyMap> {\n    const imageData = await this.imageLoader.imageData;\n    const maskData = await this.getMaskData();\n\n    this.seamGrid = new Uint16Array(imageData.width * imageData.height).fill(\n      65535\n    ) as SeamPixelPriorityGrid;\n\n    return new EnergyMap({ imageData, maskData });\n  }\n\n  abstract generateSeamBatch(): Promise<void>;\n\n  protected async getMaskData(): Promise<GrayscalePixelArray | undefined> {\n    if (!this.maskLoader) return undefined;\n\n    const maskData = await this.maskLoader.imageData;\n    return getGrayscaleImageData(maskData, false);\n  }\n\n  async generateSeamGrid(minSeams: number): Promise<SeamPixelPriorityGrid> {\n    const { width } = await this.imageLoader.image;\n\n    if (width < minSeams) {\n      throw new Error(`Cannot generate ${minSeams} seams for image with width ${width}`);\n    }\n\n    while (this.generatedSeams < minSeams) {\n      await this.generateSeamBatch();\n    }\n\n    return this.seamGrid;\n  }\n}\n", "import { deterministicBinaryRnd } from '../../utils/deterministic-binary-rnd/deterministic-binary-rnd';\nimport { EnergyMap } from '../energy-map/energy-map';\nimport { BaseGenerator, BaseGeneratorOptions } from '../base-generator/base-generator';\nimport { registerGenerator } from '../generator/generator';\n\n/**\n * The general idea here is to create random, but deterministic seams for the entire image.  They\n * need to be deterministic so that we can ensure 100% image coverage, and that no 2 seams travel\n * through the same pixel.  Then we sort them by energy, and remove a batch of the lowest energy\n * seams.  We then restart the process from scratch until we have the desired number of seams.\n *\n * The random seams are created by a deterministic random number generator basically deciding if\n * every pair of pixels should continue straight down, or if they should be swapped with one\n * another.  Repeat for the entire image and voila, we have random deterministic seams.\n *\n * So the entire algorithm is O(n) where n is the number of pixels in the image.\n */\n\ntype RandomSpecificOptions = {\n  batchPercentage?: number;\n  minBatchSize?: number;\n};\n\nexport type RandomGeneratorOptions = BaseGeneratorOptions & RandomSpecificOptions;\n\ntype RandomInstanceOptions = BaseGeneratorOptions & Required<RandomSpecificOptions>;\n\nconst defaultOptions: Required<RandomSpecificOptions> = {\n  batchPercentage: 0.05,\n  minBatchSize: 10,\n};\n\nexport class RandomGenerator extends BaseGenerator {\n  protected connections: Int8Array[] = [];\n  protected options: RandomInstanceOptions;\n\n  constructor(options: RandomGeneratorOptions) {\n    super(options);\n    this.options = { ...defaultOptions, ...options };\n  }\n\n  setBatchPercentage(percentage: number): void {\n    this.options.batchPercentage = percentage;\n  }\n\n  async generateSeamBatch(): Promise<void> {\n    const energyMap = await this.energyMapPromise;\n    const originalIndices = energyMap.originalIndices;\n    const currentWidth = energyMap.width;\n    const currentHeight = energyMap.height;\n    this.generateConnections(currentWidth, currentHeight);\n    const seams = Array.from({ length: currentWidth }, (_, ix) => this.getSeam(energyMap, ix));\n    seams.sort((a, b) => a.energy - b.energy);\n\n    const batchSize = Math.max(\n      // the '>> 1 << 1' ensures that the batch size is even.\n      (Math.ceil(currentWidth * this.options.batchPercentage) >> 1) << 1,\n      Math.min(this.options.minBatchSize, currentWidth)\n    );\n    const batchSeams = seams.slice(0, batchSize);\n\n    let seamIndex = this.generatedSeams;\n    for (let i = 0; i < batchSeams.length; i++) {\n      const seam = batchSeams[i]!;\n      seam.seam.forEach((x, y) => {\n        const originalIndex = originalIndices[y]![x]!;\n        if (this.seamGrid[originalIndex] !== 65535) {\n          throw new Error('Seam overlap detected');\n        }\n        this.seamGrid[originalIndex] = seamIndex;\n      });\n      seamIndex++;\n    }\n\n    energyMap.removeSeams(batchSeams.map((seam) => seam.seam));\n    this.generatedSeams += batchSeams.length;\n  }\n\n  protected generateConnections(width: number, height: number): void {\n    const rndGenerator = deterministicBinaryRnd(width * height + 1);\n\n    this.connections = Array.from({ length: height }, () => new Int8Array(width));\n    const lastColIx = width - 1;\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        if (x === lastColIx || rndGenerator(y * width + x)) {\n          this.connections[y]![x] = 0;\n        } else {\n          this.connections[y]![x] = 1;\n          this.connections[y]![x + 1] = -1;\n          x++;\n        }\n      }\n    }\n  }\n\n  protected getSeam(energyMap: EnergyMap, ix: number): { seam: Uint16Array; energy: number } {\n    const height = energyMap.height;\n    const seam = new Uint16Array(height);\n    const energyMapData = energyMap.energyMap;\n    let energy = 0;\n    let lastX = ix;\n\n    for (let y = 0; y < height; y++) {\n      seam[y] = lastX = lastX + this.connections[y]![lastX]!;\n      energy += energyMapData[y]![lastX]!;\n    }\n\n    return { seam, energy };\n  }\n}\n\nif (typeof RANDOM_GENERATOR !== 'undefined' && RANDOM_GENERATOR) {\n  registerGenerator('random', RandomGenerator);\n}\n", "import { RandomGenerator, RandomGeneratorOptions } from '../random-generator/random-generator';\nimport {\n  PredictiveGenerator,\n  PredictiveGeneratorOptions,\n} from '../predictive-generator/predictive-generator';\nimport { name as packageName } from '../../../package.json';\n\nexport type GeneratorType = 'random' | 'predictive';\nexport type GeneratorImpl = RandomGenerator | PredictiveGenerator;\n\nexport type GeneratorOptions =\n  | ({ generator?: 'random' } & RandomGeneratorOptions)\n  | ({ generator: 'predictive' } & PredictiveGeneratorOptions);\n\nconst generatorRegistry = new Map<GeneratorType, new (options: any) => GeneratorImpl>();\n\nexport function registerGenerator(\n  algorithm: GeneratorType,\n  constructor: new (options: any) => GeneratorImpl\n) {\n  Promise.resolve().then(() => {\n    generatorRegistry.set(algorithm, constructor);\n  });\n}\n\nexport function createGenerator(options: GeneratorOptions) {\n  const algorithm = options.generator ?? 'random';\n  const GeneratorConstructor = generatorRegistry.get(algorithm);\n\n  if (!GeneratorConstructor) {\n    throw new Error(\n      `[${packageName}] Generator '${algorithm}' is not registered or included in the build.`\n    );\n  }\n\n  return new GeneratorConstructor(options);\n}\n\n// These will self-register\nimport '../random-generator/random-generator';\nimport '../predictive-generator/predictive-generator';\n", "export class Profiler {\n  #log: (str: string) => void;\n  #times = new Map<\n    string,\n    { startTime: number; minLoggingTime: number; totalNestedTime: number }\n  >();\n  #activeStack: string[] = [];\n\n  constructor(log: (str: string) => void) {\n    this.#log = log;\n  }\n\n  start(name: string, minLoggingTime: number = 0): void {\n    this.#times.set(name, {\n      startTime: performance.now(),\n      minLoggingTime,\n      totalNestedTime: 0,\n    });\n    this.#activeStack.push(name);\n  }\n\n  end(name: string): void {\n    const { startTime, minLoggingTime, totalNestedTime } = this.#times.get(name)!;\n    const elapsedTime = performance.now() - startTime;\n\n    if (elapsedTime < minLoggingTime) return;\n\n    const stackSize = this.#activeStack.length;\n    if (stackSize > 1) {\n      const parentName = this.#activeStack[stackSize - 2]!;\n      const parentData = this.#times.get(parentName)!;\n      parentData.totalNestedTime += elapsedTime;\n    }\n\n    if (totalNestedTime > 0) {\n      this.#log(\n        `${name}: ${(elapsedTime - totalNestedTime).toFixed(2)}ms (${elapsedTime.toFixed(2)}ms)`\n      );\n    } else {\n      this.#log(`${name}: ${(elapsedTime - totalNestedTime).toFixed(2)}ms`);\n    }\n\n    this.#activeStack.pop();\n    this.#times.delete(name);\n  }\n}\n", "export function errorBoundary<T extends (this: any, ...args: any[]) => any>(\n  originalMethod: T\n): (this: ThisParameterType<T>, ...args: Parameters<T>) => ReturnType<T> | void {\n  return function replacementMethod(\n    this: ThisParameterType<T>,\n    ...args: Parameters<T>\n  ): ReturnType<T> | void {\n    if (this.hasFailed) {\n      return;\n    }\n\n    try {\n      const result = originalMethod.apply(this, args);\n      if (result && typeof result.catch === 'function') {\n        return result.catch((error: unknown) => {\n          this.handleFailure(error);\n        });\n      }\n      return result;\n    } catch (error) {\n      this.handleFailure(error);\n    }\n  };\n}\n", "export function toKebabCase(str: string): string {\n  return str.replace(/([A-Z])/g, '-$1').toLowerCase();\n}\n", "import { toKebabCase } from '../to-kebab-case/to-kebab-case';\nimport { name as packageName } from '../../../package.json';\n\nexport const createOptionGetters = <T extends object>(options: T) => {\n  const getConstrainedNumber = (_name: keyof T, defaultValue: number, min = 0, max = 1): number => {\n    const name = String(_name);\n    const value = Number(options[toKebabCase(name) as keyof T] ?? defaultValue);\n    if (value < min || value > max) {\n      throw new Error(`[${packageName}] \\`${name}\\` must be between ${min} and ${max}.`);\n    }\n    return value;\n  };\n\n  const getBoolean = (_name: keyof T, defaultValue: boolean): boolean => {\n    const name = String(_name);\n    const value = options[toKebabCase(name) as keyof T];\n    // HTML boolean attributes: presence = true, absence (null) = false, value is ignored\n    if (value === null) return false; // Explicitly removed attribute\n    return value !== undefined ? true : defaultValue;\n  };\n\n  const getEnumValue = <E extends Record<string, string>>(\n    _name: keyof T,\n    enumObject: E,\n    defaultValue: E[keyof E]\n  ): E[keyof E] => {\n    const name = String(_name);\n    const value = options[toKebabCase(name) as keyof T] as string | undefined | null;\n\n    if (value === null || value === undefined) {\n      return defaultValue;\n    }\n\n    const enumValues = Object.values(enumObject);\n    if (enumValues.includes(value)) {\n      return value as E[keyof E];\n    }\n\n    console.warn(\n      `[${packageName}] Invalid value for ${name}: \"${value}\". Defaulting to \"${defaultValue}\".`\n    );\n    return defaultValue;\n  };\n\n  return { getConstrainedNumber, getBoolean, getEnumValue };\n};\n", "export const ScalingAxis = {\n  Horizontal: 'horizontal',\n  Vertical: 'vertical',\n  Auto: 'auto',\n  Dual: 'dual',\n} as const;\n\nexport type ScalingAxis = (typeof ScalingAxis)[keyof typeof ScalingAxis];\n", "import { ImageLoader } from '../../utils/image-loader/image-loader';\nimport { GeneratorType, SeamPixelPriorityGrid } from '../../utils/types/types';\nimport { createGenerator, GeneratorOptions } from '../../generator/generator/generator';\nimport { Profiler } from '../../utils/profiler/profiler';\nimport { errorBoundary } from '../../utils/error-boundary/error-boundary';\nimport { EnergyMap } from '../../generator/energy-map/energy-map';\nimport { createOptionGetters } from '../../utils/option-helpers/option-helpers';\nimport { ScalingAxis } from '../../utils/enums/enums';\n\nimport { name as packageName } from '../../../package.json';\n\nexport interface SeamGenerator {\n  generateSeamGrid(minSeams: number): Promise<SeamPixelPriorityGrid>;\n  getImage(): Promise<HTMLImageElement>;\n  getImageData(): Promise<ImageData>;\n}\n\ntype GeneralOptions = {\n  generator?: GeneratorType;\n  carvingPriority?: number;\n  maxCarveUpSeamPercentage?: number;\n  maxCarveUpScale?: number;\n  maxCarveDownScale?: number;\n  scalingAxis?: ScalingAxis;\n  width?: number;\n  height?: number;\n  logger?: (message: string) => void;\n  showEnergyMap?: boolean;\n  demoMode?: boolean;\n};\n\ntype SeamOptions = GeneralOptions & GeneratorOptions;\ntype ProcessedSeamOptions = Required<GeneralOptions> & GeneratorOptions;\n\nexport type RendererConfig = {\n  parentNode: HTMLElement;\n  src: string;\n  generator?: GeneratorType;\n  mask?: string;\n} & SeamOptions;\n\nexport class Renderer {\n  private canvas!: HTMLCanvasElement;\n  private ctx!: CanvasRenderingContext2D;\n  private height = 0;\n  private width = 0;\n  private options!: ProcessedSeamOptions;\n  private internalHorizontalGenerator?: SeamGenerator;\n  private internalVerticalGenerator?: SeamGenerator;\n  private currentGenerator!: SeamGenerator;\n  private isVertical!: boolean;\n  private redrawQueued = false;\n  private profiler!: Profiler;\n  private hasFailed = false;\n  private parentNode: HTMLElement;\n  private src: string;\n  private mask?: string;\n  private cachedEnergyMapImageData: ImageData | null = null;\n\n  setOptions = errorBoundary(this._setOptions).bind(this);\n  private redraw = errorBoundary(this._redraw).bind(this);\n\n  constructor(config: RendererConfig) {\n    const { parentNode, src, mask, ...options } = config;\n    this.parentNode = parentNode;\n    this.src = src;\n    this.mask = mask;\n\n    try {\n      this.options = this.validateAndApplyDefaults(options);\n      this.profiler = new Profiler(this.options.logger);\n      this.initializeCanvas(parentNode);\n    } catch (e) {\n      this.handleFailure(e);\n    }\n  }\n\n  destroy(): void {\n    this.canvas.remove();\n  }\n\n  private get horizontalGenerator(): SeamGenerator {\n    if (!this.internalHorizontalGenerator) {\n      const imageLoader = new ImageLoader(this.src, { rotate: false, profiler: this.profiler });\n      const maskLoader = this.mask ? new ImageLoader(this.mask, { rotate: false }) : undefined;\n      this.internalHorizontalGenerator = this.createGenerator({ imageLoader, maskLoader });\n    }\n    return this.internalHorizontalGenerator;\n  }\n\n  private get verticalGenerator(): SeamGenerator {\n    if (!this.internalVerticalGenerator) {\n      const imageLoader = new ImageLoader(this.src, { rotate: true, profiler: this.profiler });\n      const maskLoader = this.mask ? new ImageLoader(this.mask, { rotate: true }) : undefined;\n      this.internalVerticalGenerator = this.createGenerator({ imageLoader, maskLoader });\n    }\n    return this.internalVerticalGenerator;\n  }\n\n  private determineCurrentGenerator(): SeamGenerator {\n    return this.isVertical ? this.verticalGenerator : this.horizontalGenerator;\n  }\n\n  private createGenerator(loaders: {\n    imageLoader: ImageLoader;\n    maskLoader?: ImageLoader;\n  }): SeamGenerator {\n    const options = {\n      ...this.options,\n      imageLoader: loaders.imageLoader,\n      maskLoader: loaders.maskLoader,\n    };\n\n    return createGenerator(options);\n  }\n\n  private validateAndApplyDefaults(options: SeamOptions): ProcessedSeamOptions {\n    const { getBoolean, getConstrainedNumber, getEnumValue } = createOptionGetters(options);\n\n    const newOptions: SeamOptions = {\n      ...options,\n      carvingPriority: getConstrainedNumber('carvingPriority', 1),\n      maxCarveUpSeamPercentage: getConstrainedNumber('maxCarveUpSeamPercentage', 0.6),\n      maxCarveUpScale: getConstrainedNumber('maxCarveUpScale', 10, 1, 10),\n      maxCarveDownScale: getConstrainedNumber('maxCarveDownScale', 1),\n      scalingAxis: getEnumValue('scalingAxis', ScalingAxis, ScalingAxis.Horizontal),\n      logger: options.logger ?? (() => {}),\n      showEnergyMap: getBoolean('showEnergyMap', false),\n      demoMode: getBoolean('demoMode', false),\n    };\n\n    return newOptions as ProcessedSeamOptions;\n  }\n\n  private calculateDimensions(parentNode: HTMLElement): { width: number; height: number } {\n    let { width, height } = this.options;\n    if (width === undefined || height === undefined) {\n      const parentNodeSize = parentNode.getBoundingClientRect();\n      width = width ?? parentNodeSize.width;\n      height = height ?? parentNodeSize.height;\n    }\n\n    return { width, height };\n  }\n\n  private initializeCanvas(parentNode: HTMLElement): void {\n    const { width, height } = this.calculateDimensions(parentNode);\n\n    this.canvas = document.createElement('canvas');\n    this.ctx = this.canvas.getContext('2d')!;\n    this.canvas.width = this.width = width;\n    this.canvas.height = this.height = height;\n    this.canvas.style.display = 'block';\n\n    parentNode.appendChild(this.canvas);\n\n    this.queueRedraw();\n  }\n\n  setSize(width: number, height: number): void {\n    this.width = width;\n    this.height = height;\n    this.queueRedraw();\n  }\n\n  setWidth(width: number): void {\n    this.width = width;\n    this.queueRedraw();\n  }\n\n  setHeight(height: number): void {\n    this.height = height;\n    this.queueRedraw();\n  }\n\n  private _setOptions(options: Partial<SeamOptions>): void {\n    const oldShowEnergyMap = this.options.showEnergyMap;\n\n    this.options = this.validateAndApplyDefaults({\n      ...this.options,\n      ...options,\n    } as SeamOptions);\n\n    // Invalidate energy map cache if showEnergyMap option changed\n    if (this.options.showEnergyMap !== oldShowEnergyMap) {\n      this.cachedEnergyMapImageData = null;\n    }\n\n    this.queueRedraw();\n  }\n\n  private queueRedraw(): void {\n    if (this.redrawQueued) {\n      return;\n    }\n    this.redrawQueued = true;\n\n    Promise.resolve().then(async () => {\n      await this.redraw();\n      this.redrawQueued = false;\n    });\n  }\n\n  // The total number of seams to add or remove.\n  private determineCarvingParameters(imageData: ImageData): {\n    availableSeams: number;\n    interpolationPixels: number;\n    carveDown: boolean;\n  } {\n    const { carvingPriority, maxCarveUpSeamPercentage, maxCarveUpScale, maxCarveDownScale } =\n      this.options;\n    const { width: originalWidth, height: originalHeight } = imageData;\n\n    const { isVertical, width, height } = this;\n    const logicalCanvasWidth = isVertical ? height : width;\n    const logicalCanvasHeight = isVertical ? width : height;\n\n    const targetAspectRatio = logicalCanvasWidth / logicalCanvasHeight;\n    const fullTargetWidth = Math.round(originalHeight * targetAspectRatio);\n    const targetWidth = Math.round(\n      originalWidth * (1 - carvingPriority) + fullTargetWidth * carvingPriority\n    );\n\n    const pixelDelta = originalWidth - targetWidth;\n\n    if (pixelDelta === 0) {\n      return { availableSeams: 0, interpolationPixels: 0, carveDown: false };\n    }\n\n    const seamsToCalculate = Math.abs(pixelDelta);\n    const carveDown = pixelDelta > 0;\n    const maxRatio = carveDown ? maxCarveDownScale : maxCarveUpSeamPercentage;\n    const maxSeams = originalWidth * maxRatio;\n    const direction = carveDown ? 1 : -1;\n\n    const availableSeams = Math.floor(Math.min(seamsToCalculate, maxSeams)) * direction;\n\n    if (carveDown) {\n      return { availableSeams, interpolationPixels: 0, carveDown };\n    }\n\n    const maxCarveUpImageDataWidth = Math.floor(originalWidth * maxCarveUpScale);\n    const maxPixelsByScale = maxCarveUpImageDataWidth - originalWidth;\n    const interpolationPixels = Math.max(0, Math.min(seamsToCalculate, maxPixelsByScale));\n\n    return { availableSeams: -availableSeams, interpolationPixels, carveDown };\n  }\n\n  private async determineOrientation(): Promise<boolean> {\n    if (this.options.scalingAxis === ScalingAxis.Horizontal) return false;\n    if (this.options.scalingAxis === ScalingAxis.Vertical) return true;\n\n    const { width: imageWidth, height: imageHeight } = await this.horizontalGenerator.getImage();\n    const originalAspectRatio = imageWidth / imageHeight;\n    const targetAspectRatio = this.width / this.height;\n\n    return targetAspectRatio > originalAspectRatio;\n  }\n\n  private async refreshCachedArgs(): Promise<void> {\n    this.isVertical = await this.determineOrientation();\n    this.currentGenerator = this.determineCurrentGenerator();\n  }\n\n  private async getEnergyMapImageData(): Promise<ImageData> {\n    if (this.cachedEnergyMapImageData) {\n      return this.cachedEnergyMapImageData;\n    }\n\n    const originalImageData = await this.currentGenerator.getImageData();\n    const energyMap = new EnergyMap({ imageData: originalImageData });\n    this.cachedEnergyMapImageData = energyMap.getEnergyMapAsImageData();\n\n    return this.cachedEnergyMapImageData;\n  }\n\n  private async getSourceImageData(): Promise<ImageData> {\n    if (this.options.showEnergyMap) {\n      return await this.getEnergyMapImageData();\n    } else {\n      return await this.currentGenerator.getImageData();\n    }\n  }\n\n  private async _redraw(): Promise<void> {\n    if (!this.width || !this.height) return;\n\n    this.profiler.start('redraw');\n\n    await this.refreshCachedArgs();\n    const originalImageData = await this.getSourceImageData();\n\n    const { availableSeams, interpolationPixels, carveDown } =\n      this.determineCarvingParameters(originalImageData);\n\n    let finalImageData: ImageData;\n\n    if (availableSeams === 0) {\n      finalImageData = originalImageData;\n    } else {\n      this.profiler.start('generateSeamGrid', 1);\n      const seamGrid = await this.currentGenerator.generateSeamGrid(Math.abs(availableSeams));\n      this.profiler.end('generateSeamGrid');\n\n      if (carveDown) {\n        finalImageData = this.filterPixels(originalImageData, seamGrid, availableSeams);\n      } else {\n        finalImageData = this.interpolatePixels(\n          originalImageData,\n          seamGrid,\n          availableSeams,\n          interpolationPixels\n        );\n      }\n    }\n\n    this.canvas.width = finalImageData.width;\n    this.canvas.height = finalImageData.height;\n    this.ctx.putImageData(finalImageData, 0, 0);\n\n    const styleRef = this.canvas.style;\n    const { isVertical, width, height } = this;\n\n    styleRef.transformOrigin = '0 0';\n    styleRef.transform = isVertical ? 'rotate(-90deg) translateX(-100%)' : '';\n\n    styleRef.width = `${isVertical ? height : width}px`;\n    styleRef.height = `${isVertical ? width : height}px`;\n\n    this.profiler.end('redraw');\n  }\n\n  private interpolatePixels(\n    originalImageData: ImageData,\n    seamGrid: SeamPixelPriorityGrid,\n    seamsAvailable: number,\n    totalPixelsToInsert: number\n  ): ImageData {\n    const { width: originalWidth, height, data: originalData } = originalImageData;\n    const newWidth = originalWidth + totalPixelsToInsert;\n    const newSize = newWidth * height * 4;\n    const newData = new Uint8ClampedArray(newSize);\n    let writeIndex = 0;\n    const numPixels = originalData.length / 4;\n\n    const basePixelsPerLocation = Math.floor(totalPixelsToInsert / seamsAvailable);\n    const extraPixelsCount = totalPixelsToInsert % seamsAvailable;\n\n    let x = 0;\n    for (let readIndex = 0; readIndex < numPixels; readIndex++) {\n      const priority = seamGrid[readIndex]!;\n      const readIndexRgba = readIndex * 4;\n\n      // If this pixel is a seam to be \"inserted\", add an interpolated pixel first.\n      if (priority < seamsAvailable) {\n        // Determine how many pixels to interpolate for *this specific seam*\n        // To interlace the extra pixels, we distribute them based on a calculated pattern\n        // rather than front-loading them to the lowest priority indices.\n        const addExtraPixel =\n          extraPixelsCount > 0 && (priority * extraPixelsCount) % seamsAvailable < extraPixelsCount;\n\n        const pixelsToInterpolate = addExtraPixel\n          ? basePixelsPerLocation + 1\n          : basePixelsPerLocation;\n\n        if (x === 0) {\n          // First column, just duplicate the pixel\n          for (let i = 0; i < pixelsToInterpolate; i++) {\n            newData[writeIndex] = originalData[readIndexRgba]!;\n            newData[writeIndex + 1] = originalData[readIndexRgba + 1]!;\n            newData[writeIndex + 2] = originalData[readIndexRgba + 2]!;\n            newData[writeIndex + 3] = originalData[readIndexRgba + 3]!;\n            writeIndex += 4;\n          }\n        } else {\n          // Interpolate with the pixel to the left\n          const leftReadIndexRgba = (readIndex - 1) * 4;\n\n          const r0 = originalData[leftReadIndexRgba]!;\n          const g0 = originalData[leftReadIndexRgba + 1]!;\n          const b0 = originalData[leftReadIndexRgba + 2]!;\n          const a0 = originalData[leftReadIndexRgba + 3]!;\n\n          const dr = originalData[readIndexRgba]! - r0;\n          const dg = originalData[readIndexRgba + 1]! - g0;\n          const db = originalData[readIndexRgba + 2]! - b0;\n          const da = originalData[readIndexRgba + 3]! - a0;\n\n          const denominator = pixelsToInterpolate + 1;\n          for (let i = 0; i < pixelsToInterpolate; i++) {\n            // Calculate interpolation factor for the current interpolated pixel\n            const interpolationFactor = (i + 1) / denominator;\n\n            newData[writeIndex] = Math.round(r0 + dr * interpolationFactor);\n            newData[writeIndex + 1] = Math.round(g0 + dg * interpolationFactor);\n            newData[writeIndex + 2] = Math.round(b0 + db * interpolationFactor);\n            newData[writeIndex + 3] = Math.round(a0 + da * interpolationFactor);\n            writeIndex += 4;\n          }\n        }\n      }\n\n      // Always write the original pixel\n      newData[writeIndex] = originalData[readIndexRgba]!;\n      newData[writeIndex + 1] = originalData[readIndexRgba + 1]!;\n      newData[writeIndex + 2] = originalData[readIndexRgba + 2]!;\n      newData[writeIndex + 3] = originalData[readIndexRgba + 3]!;\n      writeIndex += 4;\n\n      if (++x === originalWidth) {\n        x = 0;\n      }\n    }\n\n    if (writeIndex !== newSize) {\n      console.error(\n        `[${packageName}] Mismatch during interpolation. Wrote ${writeIndex} bytes but expected ${newSize}.`\n      );\n    }\n\n    return new ImageData(newData, newWidth, height);\n  }\n\n  private filterPixels(\n    originalImageData: ImageData,\n    seamGrid: SeamPixelPriorityGrid,\n    seamsToRemove: number\n  ): ImageData {\n    const { width: originalWidth, height, data: originalData } = originalImageData;\n    const newWidth = originalWidth - seamsToRemove;\n    const newSize = newWidth * height * 4;\n    const newData = new Uint8ClampedArray(newSize);\n    const numPixels = originalData.length / 4;\n    let writeIndex = 0;\n\n    for (let readIndex = 0; readIndex < numPixels; readIndex++) {\n      const priority = seamGrid[readIndex]!;\n\n      if (priority >= seamsToRemove) {\n        const readIndexRgba = readIndex * 4;\n\n        newData[writeIndex] = originalData[readIndexRgba]!;\n        newData[writeIndex + 1] = originalData[readIndexRgba + 1]!;\n        newData[writeIndex + 2] = originalData[readIndexRgba + 2]!;\n        newData[writeIndex + 3] = originalData[readIndexRgba + 3]!;\n\n        writeIndex += 4;\n      }\n    }\n\n    if (writeIndex !== newSize) {\n      console.error(\n        `[${packageName}] Mismatch in pixel buffer size. Expected ${newSize}, but got ${writeIndex}.`\n      );\n    }\n\n    return new ImageData(newData, newWidth, height);\n  }\n\n  private handleFailure(error: unknown): void {\n    if (this.hasFailed) return;\n\n    this.hasFailed = true;\n\n    console.error(`[${packageName}] A critical error occurred. Falling back to <img>.`, error);\n\n    this.canvas?.remove();\n\n    const img = document.createElement('img');\n\n    img.src = this.src;\n    img.style.width = '100%';\n    img.style.height = '100%';\n    img.style.display = 'block';\n\n    this.parentNode.appendChild(img);\n  }\n}\n", "import { Renderer, RendererConfig } from '../renderer/renderer';\nimport { ScalingAxis } from '../../utils/enums/enums';\nimport { toKebabCase } from '../../utils/to-kebab-case/to-kebab-case';\n\ntype SeamAttributes = Omit<RendererConfig, 'parentNode' | 'src' | 'width' | 'height' | 'logger'>;\n\nexport class FluidImg extends HTMLElement {\n  private renderer: Renderer | null = null;\n  private resizeObserver: ResizeObserver | null = null;\n  private intersectionObserver: IntersectionObserver | null = null;\n  private updateQueue = new Set<string>();\n  private isIntersecting = false;\n  private storedDimensions: { width: number; height: number } | null = null;\n  private options: Record<string, string | number | boolean> = {};\n\n  private static readonly destructiveProperties = new Set([\n    'src',\n    'scaling-axis',\n    'mask',\n    'generator',\n  ]);\n\n  constructor() {\n    super();\n  }\n\n  static get observedAttributes(): Array<\n    keyof SeamAttributes | 'src' | 'mask' | 'on-screen-threshold'\n  > {\n    const seamAttributes: Array<keyof SeamAttributes> = [\n      'generator',\n      'carvingPriority',\n      'maxCarveUpSeamPercentage',\n      'maxCarveUpScale',\n      'maxCarveDownScale',\n      'scalingAxis',\n      'showEnergyMap',\n      'mask',\n    ];\n\n    const kebabCaseAttributes = seamAttributes.map(toKebabCase);\n\n    return ['src', 'mask', 'on-screen-threshold', ...kebabCaseAttributes] as any;\n  }\n\n  connectedCallback(): void {\n    this.setupResizeObserver();\n    this.setupIntersectionObserver();\n  }\n\n  disconnectedCallback(): void {\n    this.renderer?.destroy();\n    this.renderer = null;\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = null;\n    this.intersectionObserver?.disconnect();\n    this.intersectionObserver = null;\n  }\n\n  attributeChangedCallback(name: string, oldValue: string | null, newValue: string | null): void {\n    if (oldValue === newValue) return;\n\n    if (!this.updateQueue.size) {\n      setTimeout(this.processUpdates);\n    }\n\n    this.updateQueue.add(name);\n  }\n\n  private processUpdates = (): void => {\n    const changes = Array.from(this.updateQueue);\n    this.updateQueue.clear();\n\n    if (changes.some((change) => FluidImg.destructiveProperties.has(change))) {\n      this.renderer?.destroy();\n      this.renderer = null;\n      this.initializeRenderer();\n      return;\n    }\n\n    if (changes.includes('on-screen-threshold')) {\n      this.setupIntersectionObserver();\n    }\n\n    if (!this.renderer) return;\n\n    const otherOptions = changes.reduce(\n      (acc, key) => {\n        if (key !== 'src' && key !== 'on-screen-threshold') {\n          const value = this.getAttribute(key);\n          acc[key] = value;\n        }\n        return acc;\n      },\n      {} as Record<string, string | null>\n    );\n\n    this.renderer.setOptions(otherOptions);\n  };\n\n  private dispatchLogEvent = (message: string): void => {\n    const event = new CustomEvent('log', {\n      detail: { message },\n      bubbles: true,\n      composed: true,\n    });\n    this.dispatchEvent(event);\n  };\n\n  private initializeRenderer(): void {\n    if (this.renderer) {\n      return;\n    }\n\n    const options = this.getOptions();\n    this.renderer = new Renderer({\n      parentNode: this,\n      logger: this.dispatchLogEvent,\n      ...options,\n    });\n  }\n\n  private calculateDimensions() {\n    const width = this.clientWidth ?? 100;\n    const height = this.clientHeight ?? 100;\n\n    return { width, height };\n  }\n\n  private getOptions(): any {\n    const options: Record<string, any> = {};\n    for (const attr of FluidImg.observedAttributes) {\n      const kebabCaseAttr = toKebabCase(attr);\n      if (this.hasAttribute(kebabCaseAttr)) {\n        const value = this.getAttribute(kebabCaseAttr);\n        options[attr] = { '': true, true: true, false: false }[value + ''] ?? value;\n      }\n    }\n    return options;\n  }\n\n  private setupResizeObserver(): void {\n    if (!this.parentElement) return;\n\n    this.resizeObserver = new ResizeObserver(() => {\n      const dimensions = this.calculateDimensions();\n\n      this.storedDimensions = dimensions;\n      this.attemptSetSize();\n    });\n\n    this.resizeObserver.observe(this);\n  }\n\n  private setupIntersectionObserver(): void {\n    this.intersectionObserver?.disconnect();\n\n    const threshold = this.getAttribute('on-screen-threshold') || '50px';\n    this.intersectionObserver = new IntersectionObserver(\n      (entries) => {\n        for (const entry of entries) {\n          this.isIntersecting = entry.isIntersecting;\n          if (this.isIntersecting) {\n            this.attemptSetSize();\n          }\n        }\n      },\n      {\n        rootMargin: `${threshold} ${threshold} ${threshold} ${threshold}`,\n      }\n    );\n\n    this.intersectionObserver.observe(this);\n  }\n\n  private attemptSetSize(): void {\n    if (!this.isIntersecting || !this.storedDimensions) return;\n\n    this.renderer?.setSize(this.storedDimensions.width, this.storedDimensions.height);\n    this.storedDimensions = null;\n  }\n\n  get maxCarveUpScale(): number {\n    return this.options['max-carve-up-scale'] as number;\n  }\n  set maxCarveUpScale(value: number) {\n    this.options['max-carve-up-scale'] = value;\n    this.renderer?.setOptions({ maxCarveUpScale: value });\n  }\n\n  get scalingAxis(): ScalingAxis {\n    return this.options['scaling-axis'] as ScalingAxis;\n  }\n  set scalingAxis(value: ScalingAxis) {\n    this.options['scaling-axis'] = value;\n    this.renderer?.setOptions({ scalingAxis: value });\n  }\n\n  get showEnergyMap(): boolean {\n    return this.options['show-energy-map'] as boolean;\n  }\n  set showEnergyMap(value: boolean) {\n    this.options['show-energy-map'] = value;\n    this.renderer?.setOptions({ showEnergyMap: value });\n  }\n\n  get onScreenThreshold(): number {\n    const threshold = this.getAttribute('on-screen-threshold') || '50px';\n    return parseInt(threshold.replace('px', ''), 10);\n  }\n}\n\ncustomElements.define('fluid-img', FluidImg);\n"],
  "mappings": "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",
  "names": ["EvenWidthImage", "#rotate", "options", "originalWidth", "ImageLoader", "#src", "#imgPromise", "#imageDataPromise", "#profiler", "src", "profiler", "#loadImage", "img", "#loadImageData", "resolve", "reject", "image", "context", "imageData", "name", "deterministicBinaryRnd", "seed1", "seed2", "h", "deleteArrayIndices", "array", "uniqueSortedIndicesToRemove", "elementsPerRemoval", "newSize", "ArrayConstructor", "result", "resultOffset", "sourceStart", "lastIndex", "deleteIndex", "chunkSize", "getGrayscaleImageData", "imageData", "asRows", "useLinearApproximation", "data", "width", "height", "grayscaleData", "y", "rowOffset", "currentArray", "x", "ix", "r", "b", "a", "gray", "SobelEnergyMap", "#data", "#width", "#height", "#grayscaleMap", "#originalIndices", "#maskData", "options", "imageData", "maskData", "getGrayscaleImageData", "#fillOriginalIndices", "#computeFullEnergyMap", "#getMaskEnergy", "y", "x", "originalIndex", "width", "height", "energyMapData", "y1", "y3", "prevRow", "currentRow", "nextRow", "x1", "x3", "gx", "gy", "sobelEnergy", "maskEnergy", "energyMap", "originalIndices", "removeSeam", "xIndices", "xToRemove", "deleteArrayIndices", "g", "colInNewCoord", "removedOriginalIndex", "removedColOrigIdx", "columnsInNewDataToUpdate", "xCurrent", "xCenter", "removeSeams", "seams", "numSeamsToRemove", "indicesToRemoveForRow", "seamPath", "b", "getEnergyMapAsImageData", "minEnergy", "maxEnergy", "energy", "energyRange", "data", "index", "normalizedEnergy", "registerEnergyMap", "energyMapRegistry", "registerEnergyMap", "algorithm", "constructor", "createEnergyMap", "options", "EnergyMapConstructor", "name", "EnergyMap", "impl", "options", "createEnergyMap", "energyMap", "originalIndices", "removeSeam", "xIndices", "removeSeams", "seams", "getEnergyMapAsImageData", "width", "height", "BaseGenerator", "imageLoader", "maskLoader", "energyMapPromise", "seamGrid", "generatedSeams", "options", "createEnergyMap", "imageData", "getImage", "image", "maskData", "getMaskData", "EnergyMap", "getGrayscaleImageData", "generateSeamGrid", "minSeams", "width", "generateSeamBatch", "defaultOptions", "batchPercentage", "minBatchSize", "RandomGenerator", "BaseGenerator", "options", "setBatchPercentage", "percentage", "generateSeamBatch", "energyMap", "energyMapPromise", "originalIndices", "currentWidth", "currentHeight", "generateConnections", "seams", "_", "ix", "getSeam", "a", "b", "energy", "batchSize", "batchSeams", "seamIndex", "generatedSeams", "i", "seam", "x", "y", "originalIndex", "seamGrid", "removeSeams", "width", "height", "rndGenerator", "deterministicBinaryRnd", "lastColIx", "energyMapData", "lastX", "registerGenerator", "generatorRegistry", "registerGenerator", "algorithm", "constructor", "createGenerator", "options", "GeneratorConstructor", "name", "Profiler", "#log", "#times", "#activeStack", "log", "name", "minLoggingTime", "totalNestedTime", "startTime", "elapsedTime", "stackSize", "parentName", "parentData", "errorBoundary", "originalMethod", "args", "hasFailed", "result", "error", "handleFailure", "toKebabCase", "str", "createOptionGetters", "options", "getConstrainedNumber", "_name", "defaultValue", "min", "max", "name", "value", "toKebabCase", "getBoolean", "getEnumValue", "enumObject", "ScalingAxis", "Horizontal", "Vertical", "Auto", "Dual", "Renderer", "ctx", "internalHorizontalGenerator", "internalVerticalGenerator", "currentGenerator", "isVertical", "redrawQueued", "profiler", "hasFailed", "cachedEnergyMapImageData", "setOptions", "errorBoundary", "_setOptions", "redraw", "_redraw", "config", "parentNode", "src", "mask", "options", "validateAndApplyDefaults", "Profiler", "logger", "initializeCanvas", "e", "handleFailure", "horizontalGenerator", "imageLoader", "ImageLoader", "maskLoader", "createGenerator", "verticalGenerator", "determineCurrentGenerator", "loaders", "getBoolean", "getConstrainedNumber", "getEnumValue", "createOptionGetters", "ScalingAxis", "Horizontal", "demoMode", "calculateDimensions", "width", "height", "parentNodeSize", "queueRedraw", "setSize", "setWidth", "setHeight", "oldShowEnergyMap", "determineCarvingParameters", "imageData", "carvingPriority", "maxCarveUpSeamPercentage", "maxCarveUpScale", "maxCarveDownScale", "originalWidth", "originalHeight", "targetAspectRatio", "fullTargetWidth", "targetWidth", "pixelDelta", "availableSeams", "interpolationPixels", "carveDown", "seamsToCalculate", "maxSeams", "direction", "maxPixelsByScale", "determineOrientation", "Vertical", "imageWidth", "imageHeight", "getImage", "originalAspectRatio", "refreshCachedArgs", "getEnergyMapImageData", "originalImageData", "energyMap", "EnergyMap", "getEnergyMapAsImageData", "getSourceImageData", "finalImageData", "seamGrid", "generateSeamGrid", "filterPixels", "interpolatePixels", "styleRef", "seamsAvailable", "totalPixelsToInsert", "originalData", "newWidth", "newSize", "newData", "writeIndex", "numPixels", "basePixelsPerLocation", "extraPixelsCount", "x", "readIndex", "priority", "readIndexRgba", "pixelsToInterpolate", "i", "leftReadIndexRgba", "r0", "g0", "b0", "a0", "dr", "dg", "db", "da", "denominator", "interpolationFactor", "name", "seamsToRemove", "error", "img", "FluidImg", "_FluidImg", "renderer", "resizeObserver", "intersectionObserver", "updateQueue", "storedDimensions", "destructiveProperties", "toKebabCase", "setupResizeObserver", "setupIntersectionObserver", "name", "oldValue", "newValue", "processUpdates", "changes", "change", "initializeRenderer", "otherOptions", "acc", "key", "value", "setOptions", "dispatchLogEvent", "message", "event", "options", "getOptions", "Renderer", "logger", "calculateDimensions", "width", "height", "attr", "kebabCaseAttr", "dimensions", "attemptSetSize", "threshold", "entries", "entry", "setSize"]
}
