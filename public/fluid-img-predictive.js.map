{
  "version": 3,
  "sources": ["../src/utils/image-loader/image-loader.ts", "../package.json", "../src/utils/delete-array-indicies/delete-array-indicies.ts", "../src/generator/grayscale/grayscale.ts", "../src/generator/sobel-energy-map/sobel-energy-map.ts", "../src/generator/energy-map-registry/energy-map-registry.ts", "../src/generator/energy-map/energy-map.ts", "../src/generator/base-generator/base-generator.ts", "../src/generator/minimal-cumulative-energy-map/minimal-cumulative-energy-map.ts", "../src/utils/sliding-window-maximum/sliding-window-maximum.ts", "../src/generator/predictive-generator/predictive-generator.ts", "../src/generator/generator/generator.ts", "../src/utils/profiler/profiler.ts", "../src/utils/error-boundary/error-boundary.ts", "../src/utils/to-kebab-case/to-kebab-case.ts", "../src/utils/option-helpers/option-helpers.ts", "../src/utils/enums/enums.ts", "../src/renderer/renderer/renderer.ts", "../src/renderer/web-component/web-component.ts"],
  "sourcesContent": ["import { Profiler } from '../../utils/profiler/profiler';\n\nclass EvenWidthImage extends Image {\n  #rotate: boolean;\n\n  constructor(options: { rotate?: boolean } = {}) {\n    super();\n    this.crossOrigin = `Anonymous`;\n    this.#rotate = !!options.rotate;\n  }\n\n  override get width(): number {\n    const originalWidth = this.#rotate ? super.height : super.width;\n    return originalWidth - (originalWidth % 2);\n  }\n\n  override get height(): number {\n    return this.#rotate ? super.width : super.height;\n  }\n}\n\nexport class ImageLoader {\n  #src: string;\n  #imgPromise: Promise<HTMLImageElement>;\n  #imageDataPromise: Promise<ImageData>;\n  #rotate: boolean;\n  #profiler?: Profiler;\n\n  constructor(src: string, options: { rotate: boolean; profiler?: Profiler }) {\n    this.#src = src;\n    this.#rotate = options.rotate;\n    this.#profiler = options.profiler;\n    this.#imgPromise = this.#loadImage();\n    this.#imageDataPromise = this.#imgPromise.then((img) => this.#loadImageData(img));\n  }\n\n  #loadImage(): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n      const src = this.#src;\n      const img = new EvenWidthImage({ rotate: this.#rotate });\n      img.onload = () => resolve(img);\n      img.onerror = () => reject(`Failed to load image: ${src}`);\n      img.onabort = () => reject(`Image loading aborted: ${src}`);\n      img.src = src;\n    });\n  }\n\n  #loadImageData(image: HTMLImageElement): Promise<ImageData> {\n    const profiler = this.#profiler;\n\n    return new Promise((resolve) => {\n      profiler?.start('loadImageData');\n      const canvas = new OffscreenCanvas(image.width, image.height);\n      const context = canvas.getContext('2d')!;\n\n      if (this.#rotate) {\n        context.translate(image.width, 0);\n        context.rotate(Math.PI / 2);\n      }\n\n      context.drawImage(image, 0, 0);\n\n      const imageData = context.getImageData(0, 0, image.width, image.height);\n\n      profiler?.end('loadImageData');\n\n      resolve(imageData);\n    });\n  }\n\n  get src(): string {\n    return this.#src;\n  }\n\n  get image(): Promise<HTMLImageElement> {\n    return this.#imgPromise;\n  }\n\n  get imageData(): Promise<ImageData> {\n    return this.#imageDataPromise;\n  }\n}\n", "{\n  \"name\": \"fluid-img\",\n  \"version\": \"0.2.0\",\n  \"description\": \"A web component for displaying images that intelligently resize to fit most any container.\",\n  \"author\": \"Voice NPO, Inc.\",\n  \"license\": \"Fluid-Img Revenue-Limited License\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/VoiceNGO/fluid-img.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/VoiceNGO/fluid-img/issues\"\n  },\n  \"homepage\": \"https://voicengo.github.io/fluid-img/public/fluid-demo.html\",\n  \"type\": \"module\",\n  \"main\": \"./dist/fluid-img.js\",\n  \"module\": \"./dist/fluid-img.js\",\n  \"types\": \"./dist/fluid-img.d.ts\",\n  \"files\": [\n    \"dist\",\n    \"src\",\n    \"README.md\"\n  ],\n  \"exports\": {\n    \".\": \"./dist/fluid-img.js\",\n    \"./random\": \"./dist/fluid-img-random.js\",\n    \"./predictive\": \"./dist/fluid-img-predictive.js\"\n  },\n  \"scripts\": {\n    \"test\": \"vitest -t \\\"^[^@]+$\\\"\",\n    \"test:live\": \"vitest -t \\\"@LIVE\\\"\",\n    \"test:watch\": \"vitest watch\",\n    \"build\": \"npm run build:all && npm run build:random && npm run build:predictive && npm run build:demo && npm run copy-to-docs\",\n    \"watch\": \"npm run watch:all & npm run watch:random & npm run watch:predictive & npm run watch:demo\",\n    \"build:all\": \"node scripts/build.js --RANDOM_GENERATOR=true --PREDICTIVE_GENERATOR=true --outfile=dist/fluid-img.js\",\n    \"build:random\": \"node scripts/build.js --RANDOM_GENERATOR=true --outfile=dist/fluid-img-random.js\",\n    \"build:predictive\": \"node scripts/build.js --PREDICTIVE_GENERATOR=true --outfile=dist/fluid-img-predictive.js\",\n    \"build:demo\": \"node scripts/build.js --RANDOM_GENERATOR=true --PREDICTIVE_GENERATOR=true --DEMO=true --outfile=dist/fluid-img-demo.js\",\n    \"watch:all\": \"npm run build:all -- --watch\",\n    \"watch:random\": \"npm run build:random -- --watch\",\n    \"watch:predictive\": \"npm run build:predictive -- --watch\",\n    \"watch:demo\": \"npm run build:demo -- --watch\",\n    \"copy-to-docs\": \"cp ./dist/* ./docs/public/.\"\n  },\n  \"devDependencies\": {\n    \"esbuild\": \"^0.25.4\",\n    \"eslint\": \"^9.27.0\",\n    \"prettier\": \"^3.5.3\",\n    \"type-fest\": \"^4.41.0\",\n    \"typescript\": \"^5.8.3\",\n    \"vitest\": \"^3.1.4\",\n    \"@types/node\": \"^22.15.21\"\n  }\n}\n", "import type { TypedArray, Constructor } from 'type-fest';\n\nexport function deleteArrayIndices<T extends TypedArray>(\n  array: T,\n  uniqueSortedIndicesToRemove: number[],\n  elementsPerRemoval: number = 1\n): T {\n  const newSize = array.length - uniqueSortedIndicesToRemove.length * elementsPerRemoval;\n  const ArrayConstructor = array.constructor as Constructor<T>;\n  const result = new ArrayConstructor(newSize) as T;\n\n  let resultOffset = 0;\n  let sourceStart = 0;\n  let lastIndex = -1;\n\n  for (const deleteIndex of uniqueSortedIndicesToRemove) {\n    if (lastIndex === deleteIndex) {\n      throw new Error('[deleteArrayIndices]: Duplicate index detected');\n    }\n    if (lastIndex > deleteIndex) {\n      throw new Error('[deleteArrayIndices]: Indices are not sorted');\n    }\n\n    const chunkSize = deleteIndex - sourceStart;\n\n    if (chunkSize > 0) {\n      (result as any).set(array.subarray(sourceStart, deleteIndex), resultOffset);\n      resultOffset += chunkSize;\n    }\n\n    sourceStart = deleteIndex + elementsPerRemoval;\n    lastIndex = deleteIndex;\n  }\n\n  if (sourceStart < array.length) {\n    (result as any).set(array.subarray(sourceStart), resultOffset);\n  }\n\n  return result;\n}\n", "import { GrayscalePixelArray } from '../../utils/types/types';\n\nexport function getGrayscaleImageData<AsRows extends boolean>(\n  imageData: ImageData,\n  asRows: AsRows,\n  useLinearApproximation = false\n): AsRows extends true ? Uint8Array[] : GrayscalePixelArray {\n  const { data, width, height } = imageData;\n  const grayscaleData = asRows ? new Array(height) : new Uint8Array(width * height);\n\n  for (let y = 0; y < height; y++) {\n    const rowOffset = y * width;\n    const currentArray = asRows ? (grayscaleData[y] = new Uint8Array(width)) : grayscaleData;\n\n    for (let x = 0; x < width; x++) {\n      const ix = (rowOffset + x) * 4;\n      const r = data[ix];\n      const g = data[ix + 1];\n      const b = data[ix + 2];\n      const a = data[ix + 3];\n\n      let gray;\n      if (useLinearApproximation) {\n        gray = (((r! + g! + b!) / 3) * a!) / 255;\n      } else {\n        gray = ((0.299 * r! + 0.587 * g! + 0.114 * b!) * a!) / 255;\n      }\n\n      currentArray[asRows ? x : rowOffset + x] = gray;\n    }\n  }\n\n  return grayscaleData as any;\n}\n", "// TODO: Test Sobel energy calculation using sqrt(Gx^2 + Gy^2) and adjust normalization for comparison.\n// Current method uses abs(Gx) + abs(Gy).\nimport type { Tagged } from 'type-fest';\nimport { deleteArrayIndices } from '../../utils/delete-array-indicies/delete-array-indicies';\nimport { getGrayscaleImageData } from '../grayscale/grayscale';\nimport { GrayscalePixelArray } from '../../utils/types/types';\nimport {\n  registerEnergyMap,\n  SobelEnergyMapOptions,\n} from '../energy-map-registry/energy-map-registry';\n\ntype EnergyMapData = Tagged<Uint16Array, 'energyMapData'>;\ntype EnergyMapIndices = Tagged<Uint32Array, 'energyMapIndices'>;\n\nexport class SobelEnergyMap {\n  #data: EnergyMapData[];\n  #width: number;\n  #height: number;\n  #grayscaleMap: Uint8Array[];\n  #originalIndices: EnergyMapIndices[];\n  #maskData?: GrayscalePixelArray;\n\n  constructor(options: SobelEnergyMapOptions) {\n    this.#width = options.imageData.width;\n    this.#height = options.imageData.height;\n    this.#data = new Array(this.#height);\n    this.#originalIndices = new Array(this.#height);\n    this.#maskData = options.maskData;\n\n    this.#grayscaleMap = getGrayscaleImageData(options.imageData, true);\n    this.#fillOriginalIndices();\n    this.#data = this.#computeFullEnergyMap();\n  }\n\n  #getMaskEnergy(y: number, x: number): number {\n    if (!this.#maskData) {\n      return 255;\n    }\n    const originalIndex = this.#originalIndices[y]![x]!;\n    return this.#maskData[originalIndex]!;\n  }\n\n  #fillOriginalIndices(): void {\n    for (let y = 0; y < this.#height; y++) {\n      this.#originalIndices[y] = new Uint32Array(this.#width) as EnergyMapIndices;\n      for (let x = 0; x < this.#width; x++) {\n        this.#originalIndices[y]![x] = y * this.#width + x;\n      }\n    }\n  }\n\n  #computeFullEnergyMap(\n    width: number = this.#width,\n    height: number = this.#height\n  ): EnergyMapData[] {\n    const energyMapData: EnergyMapData[] = new Array(height);\n\n    for (let y = 0; y < height; y++) {\n      energyMapData[y] = new Uint16Array(width) as EnergyMapData;\n\n      const y1 = Math.max(0, y - 1);\n      const y3 = Math.min(height - 1, y + 1);\n      const prevRow = this.#grayscaleMap[y1]!;\n      const currentRow = this.#grayscaleMap[y]!;\n      const nextRow = this.#grayscaleMap[y3]!;\n\n      for (let x = 0; x < width; x++) {\n        const x1 = Math.max(0, x - 1);\n        const x3 = Math.min(width - 1, x + 1);\n\n        const gx =\n          -prevRow[x1]! +\n          prevRow[x3]! +\n          -currentRow[x1]! * 2 +\n          currentRow[x3]! * 2 +\n          -nextRow[x1]! +\n          nextRow[x3]!;\n\n        const gy =\n          -prevRow[x1]! +\n          -prevRow[x]! * 2 +\n          -prevRow[x3]! +\n          nextRow[x1]! +\n          nextRow[x]! * 2 +\n          nextRow[x3]!;\n\n        const sobelEnergy = (gx < 0 ? -gx : gx) + (gy < 0 ? -gy : gy);\n        const maskEnergy = this.#getMaskEnergy(y, x);\n        energyMapData[y]![x] = sobelEnergy * (maskEnergy / 255);\n      }\n    }\n\n    return energyMapData;\n  }\n\n  get width(): number {\n    return this.#width;\n  }\n\n  get height(): number {\n    return this.#height;\n  }\n\n  get energyMap(): readonly EnergyMapData[] {\n    return this.#data;\n  }\n\n  get originalIndices(): readonly EnergyMapIndices[] {\n    return this.#originalIndices;\n  }\n\n  removeSeam(xIndices: Uint16Array): void {\n    for (let y = 0; y < this.#height; y++) {\n      const xToRemove = xIndices[y]!;\n      this.#data[y] = deleteArrayIndices(this.#data[y]!, [xToRemove]);\n      this.#originalIndices[y] = deleteArrayIndices(this.#originalIndices[y]!, [xToRemove]);\n    }\n    this.#width--;\n\n    const g = (colInNewCoord: number, removedOriginalIndex: number) =>\n      colInNewCoord < removedOriginalIndex ? colInNewCoord : colInNewCoord + 1;\n\n    for (let y = 0; y < this.#height; y++) {\n      const removedColOrigIdx = xIndices[y]!;\n\n      // Cache row references with clamping\n      const y1 = Math.max(0, y - 1);\n      const y3 = Math.min(this.#height - 1, y + 1);\n      const prevRow = this.#grayscaleMap[y1]!;\n      const currentRow = this.#grayscaleMap[y]!;\n      const nextRow = this.#grayscaleMap[y3]!;\n\n      const columnsInNewDataToUpdate: number[] = [];\n      if (removedColOrigIdx > 0) {\n        columnsInNewDataToUpdate.push(removedColOrigIdx - 1);\n      }\n      if (removedColOrigIdx < this.#width) {\n        columnsInNewDataToUpdate.push(removedColOrigIdx);\n      }\n\n      for (const xCurrent of columnsInNewDataToUpdate) {\n        const x1 = Math.max(0, g(xCurrent - 1, removedColOrigIdx));\n        const x3 = Math.min(this.#grayscaleMap[0]!.length - 1, g(xCurrent + 1, removedColOrigIdx));\n        const xCenter = g(xCurrent, removedColOrigIdx);\n\n        const gx =\n          -prevRow[x1]! +\n          prevRow[x3]! +\n          -currentRow[x1]! * 2 +\n          currentRow[x3]! * 2 +\n          -nextRow[x1]! +\n          nextRow[x3]!;\n\n        const gy =\n          -prevRow[x1]! +\n          -prevRow[xCenter]! * 2 +\n          -prevRow[x3]! +\n          nextRow[x1]! +\n          nextRow[xCenter]! * 2 +\n          nextRow[x3]!;\n\n        const sobelEnergy = (gx < 0 ? -gx : gx) + (gy < 0 ? -gy : gy);\n        const maskEnergy = this.#getMaskEnergy(y, xCurrent);\n        this.#data[y]![xCurrent] = sobelEnergy + maskEnergy;\n      }\n    }\n  }\n\n  removeSeams(seams: Uint16Array[]): void {\n    if (seams.length === 0) {\n      return;\n    }\n\n    const numSeamsToRemove = seams.length;\n\n    for (let y = 0; y < this.#height; y++) {\n      const indicesToRemoveForRow: number[] = seams\n        .map((seamPath) => seamPath[y]!)\n        .sort((a, b) => a - b);\n\n      this.#data[y] = deleteArrayIndices(this.#data[y]!, indicesToRemoveForRow);\n      this.#grayscaleMap[y] = deleteArrayIndices(this.#grayscaleMap[y]!, indicesToRemoveForRow);\n      this.#originalIndices[y] = deleteArrayIndices(\n        this.#originalIndices[y]!,\n        indicesToRemoveForRow\n      );\n    }\n\n    this.#width -= numSeamsToRemove;\n\n    this.#data = this.#computeFullEnergyMap();\n  }\n\n  getEnergyMapAsImageData(width: number = this.#width, height: number = this.#height): ImageData {\n    const energyMapData = this.#computeFullEnergyMap(width, height);\n\n    // Find min and max energy values for normalization\n    let minEnergy = Infinity;\n    let maxEnergy = 0;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const energy = energyMapData[y]![x]!;\n        if (energy < minEnergy) minEnergy = energy;\n        if (energy > maxEnergy) maxEnergy = energy;\n      }\n    }\n\n    const energyRange = maxEnergy - minEnergy;\n    const imageData = new ImageData(width, height);\n    const data = imageData.data;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const index = (y * width + x) * 4;\n        const energy = energyMapData[y]![x]!;\n\n        // Normalize energy to 0-255 range\n        const normalizedEnergy =\n          energyRange > 0 ? Math.round(((energy - minEnergy) / energyRange) * 255) : 0;\n\n        // Set RGB channels to the same value for grayscale\n        data[index] = normalizedEnergy; // R\n        data[index + 1] = normalizedEnergy; // G\n        data[index + 2] = normalizedEnergy; // B\n        data[index + 3] = 255; // A (100% alpha)\n      }\n    }\n\n    return imageData;\n  }\n}\n\nif (typeof SOBEL_ENERGY_MAP !== 'undefined' && SOBEL_ENERGY_MAP) {\n  registerEnergyMap('sobel', SobelEnergyMap);\n}\n", "import { BoundaryAwareEnergyMap } from '../boundary-aware-energy-map/boundary-aware-energy-map';\nimport { DualEnergyMap } from '../dual-energy-map/dual-energy-map';\nimport { SobelEnergyMap } from '../sobel-energy-map/sobel-energy-map';\nimport { GrayscalePixelArray } from '../../utils/types/types';\nimport { name as packageName } from '../../../package.json';\n\nexport type EnergyMapAlgorithm = 'sobel' | 'dual' | 'boundary-aware';\nexport type EnergyMapImpl = SobelEnergyMap | DualEnergyMap | BoundaryAwareEnergyMap;\n\n//#region Options Types\ntype BaseEnergyMapOptions = {\n  imageData: ImageData;\n  maskData?: GrayscalePixelArray;\n};\n\nexport type SobelEnergyMapOptions = BaseEnergyMapOptions & {\n  algorithm?: 'sobel';\n};\n\nexport type DualEnergyMapOptions = BaseEnergyMapOptions & {\n  algorithm: 'dual';\n  forwardEnergyWeight?: number;\n};\n\nexport type BoundaryAwareEnergyMapOptions = BaseEnergyMapOptions & {\n  algorithm: 'boundary-aware';\n  boundaryPenaltyWeight?: number;\n  uniformityThreshold?: number;\n  edgeThreshold?: number;\n};\n\nexport type EnergyMapOptions =\n  | SobelEnergyMapOptions\n  | DualEnergyMapOptions\n  | BoundaryAwareEnergyMapOptions;\n\nconst energyMapRegistry = new Map<EnergyMapAlgorithm, new (options: any) => EnergyMapImpl>();\n\nexport function registerEnergyMap(\n  algorithm: EnergyMapAlgorithm,\n  constructor: new (options: any) => EnergyMapImpl\n) {\n  Promise.resolve().then(() => {\n    energyMapRegistry.set(algorithm, constructor);\n  });\n}\n\nexport function createEnergyMap(options: EnergyMapOptions) {\n  const algorithm = options.algorithm ?? 'sobel';\n  const EnergyMapConstructor = energyMapRegistry.get(algorithm);\n\n  if (!EnergyMapConstructor) {\n    throw new Error(\n      `[${packageName}] Energy map algorithm '${algorithm}' is not registered or included in the build.`\n    );\n  }\n\n  return new EnergyMapConstructor(options);\n}\n\n// These will self-register\nimport '../sobel-energy-map/sobel-energy-map';\nimport '../dual-energy-map/dual-energy-map';\nimport '../boundary-aware-energy-map/boundary-aware-energy-map';\n", "import { GrayscalePixelArray } from '../../utils/types/types';\nimport {\n  createEnergyMap,\n  EnergyMapAlgorithm,\n  EnergyMapImpl,\n  EnergyMapOptions,\n} from '../energy-map-registry/energy-map-registry';\nimport { BoundaryAwareEnergyMap } from '../boundary-aware-energy-map/boundary-aware-energy-map';\nimport { DualEnergyMap } from '../dual-energy-map/dual-energy-map';\nimport { SobelEnergyMap } from '../sobel-energy-map/sobel-energy-map';\n\nexport const EnergyMap = class EnergyMap {\n  private impl: EnergyMapImpl;\n\n  constructor(options: EnergyMapOptions) {\n    this.impl = createEnergyMap(options);\n  }\n\n  get width() {\n    return this.impl.width;\n  }\n\n  get height() {\n    return this.impl.height;\n  }\n\n  get energyMap() {\n    return this.impl.energyMap;\n  }\n\n  get originalIndices() {\n    return this.impl.originalIndices;\n  }\n\n  removeSeam(xIndices: Uint16Array) {\n    return this.impl.removeSeam(xIndices);\n  }\n\n  removeSeams(seams: Uint16Array[]) {\n    return this.impl.removeSeams(seams);\n  }\n\n  getEnergyMapAsImageData(width?: number, height?: number) {\n    return this.impl.getEnergyMapAsImageData(width, height);\n  }\n};\n\nexport type EnergyMap = InstanceType<typeof EnergyMap>;\n\nexport {\n  SobelEnergyMap,\n  DualEnergyMap,\n  BoundaryAwareEnergyMap,\n  createEnergyMap as createEnergyMapFactory,\n};\nexport type { EnergyMapAlgorithm };\n", "import { EnergyMap } from '../energy-map/energy-map';\nimport { ImageLoader } from '../../utils/image-loader/image-loader';\nimport { GrayscalePixelArray, SeamGenerator, SeamPixelPriorityGrid } from '../../utils/types/types';\nimport { getGrayscaleImageData } from '../grayscale/grayscale';\n\nexport type BaseGeneratorOptions = {\n  imageLoader: ImageLoader;\n  maskLoader?: ImageLoader;\n};\n\nexport abstract class BaseGenerator implements SeamGenerator {\n  protected imageLoader: ImageLoader;\n  protected maskLoader?: ImageLoader;\n  protected energyMapPromise: Promise<EnergyMap>;\n  protected seamGrid: SeamPixelPriorityGrid = new Uint16Array() as SeamPixelPriorityGrid;\n  protected generatedSeams = 0;\n\n  constructor(options: BaseGeneratorOptions) {\n    this.imageLoader = options.imageLoader;\n    this.maskLoader = options.maskLoader;\n    this.energyMapPromise = this.createEnergyMap();\n  }\n\n  async getImageData(): Promise<ImageData> {\n    return this.imageLoader.imageData;\n  }\n\n  async getImage(): Promise<HTMLImageElement> {\n    return this.imageLoader.image;\n  }\n\n  protected async createEnergyMap(): Promise<EnergyMap> {\n    const imageData = await this.imageLoader.imageData;\n    const maskData = await this.getMaskData();\n\n    this.seamGrid = new Uint16Array(imageData.width * imageData.height).fill(\n      65535\n    ) as SeamPixelPriorityGrid;\n\n    return new EnergyMap({ imageData, maskData });\n  }\n\n  abstract generateSeamBatch(): Promise<void>;\n\n  protected async getMaskData(): Promise<GrayscalePixelArray | undefined> {\n    if (!this.maskLoader) return undefined;\n\n    const maskData = await this.maskLoader.imageData;\n    return getGrayscaleImageData(maskData, false);\n  }\n\n  async generateSeamGrid(minSeams: number): Promise<SeamPixelPriorityGrid> {\n    const { width } = await this.imageLoader.image;\n\n    if (width < minSeams) {\n      throw new Error(`Cannot generate ${minSeams} seams for image with width ${width}`);\n    }\n\n    while (this.generatedSeams < minSeams) {\n      await this.generateSeamBatch();\n    }\n\n    return this.seamGrid;\n  }\n}\n", "import { EnergyMap } from '../energy-map/energy-map';\nimport { deleteArrayIndices } from '../../utils/delete-array-indicies/delete-array-indicies';\nimport { PickOptional } from '../../utils/types/types';\n\nexport type CumulativeEnergyMapOptions = {\n  energyMap: EnergyMap;\n  constrainTo16Bit?: boolean;\n  constrainToDiagonals?: boolean;\n  accumulateUp?: boolean;\n};\ntype RequiredCumulativeEnergyMapOptions = Required<CumulativeEnergyMapOptions>;\n\nconst cumulativeEnergyMapDefaultOptions: Required<PickOptional<CumulativeEnergyMapOptions>> = {\n  constrainTo16Bit: false,\n  constrainToDiagonals: false,\n  accumulateUp: false,\n};\n\nexport class MinimalCumulativeEnergyMap {\n  #options: RequiredCumulativeEnergyMapOptions;\n  #minimalEnergyMap: Uint16Array[] | Uint32Array[];\n  #width: number;\n  #height: number;\n\n  constructor(options: CumulativeEnergyMapOptions) {\n    this.#options = {\n      ...cumulativeEnergyMapDefaultOptions,\n      ...options,\n    };\n\n    this.#width = options.energyMap.width;\n    this.#height = options.energyMap.height;\n    this.#minimalEnergyMap = this.computeMinimalEnergyMap();\n  }\n\n  private computeMinimalEnergyMap(): Uint16Array[] | Uint32Array[] {\n    const { energyMap, constrainTo16Bit, constrainToDiagonals, accumulateUp } = this.#options;\n\n    const { width, height } = energyMap;\n    const minimalEnergyMap = new Array(height);\n    const startingRow = accumulateUp ? height - 1 : 0;\n    const endingRow = accumulateUp ? -1 : height;\n    const increment = accumulateUp ? -1 : 1;\n    const divisor = constrainTo16Bit ? height / 256 : 1;\n    const shiftAmount = constrainTo16Bit ? Math.ceil(Math.log2(divisor)) : 0;\n    const energyMapData = energyMap.energyMap;\n\n    // Just copy the first row\n    minimalEnergyMap[startingRow] = new (constrainTo16Bit ? Uint16Array : Uint32Array)(\n      energyMapData[startingRow]!\n    );\n\n    for (let row = startingRow + increment; row !== endingRow; row += increment) {\n      minimalEnergyMap[row] = new (constrainTo16Bit ? Uint16Array : Uint32Array)(width);\n\n      for (let col = 0; col < width; col++) {\n        const energy = energyMapData[row]![col]!;\n\n        const prevLeftEnergy = minimalEnergyMap[row - increment][col - 1] ?? Infinity;\n        const prevRightEnergy = minimalEnergyMap[row - increment][col + 1] ?? Infinity;\n        const prevStraightEnergy = constrainToDiagonals\n          ? Infinity\n          : minimalEnergyMap[row - increment][col];\n\n        const minEnergy = Math.min(prevLeftEnergy, prevRightEnergy, prevStraightEnergy);\n\n        // minimalEnergyMap[row]![col] = (energy + minEnergy) / divisor;\n        minimalEnergyMap[row]![col] = (energy + minEnergy) >> shiftAmount;\n      }\n    }\n\n    return minimalEnergyMap;\n  }\n\n  removeSeams(seams: Uint16Array[]): void {\n    if (seams.length === 0) {\n      return;\n    }\n\n    for (let y = 0; y < this.#height; y++) {\n      const indicesToRemoveForRow: number[] = seams\n        .map((seamPath) => seamPath[y]!)\n        .sort((a, b) => a - b);\n\n      this.#minimalEnergyMap[y] = deleteArrayIndices(\n        this.#minimalEnergyMap[y]!,\n        indicesToRemoveForRow\n      );\n    }\n\n    this.#width -= seams.length;\n  }\n\n  get minimalEnergyMap(): Uint16Array[] | Uint32Array[] {\n    return this.#minimalEnergyMap;\n  }\n}\n", "import { Constructor, TypedArray } from 'type-fest';\n\nexport class SlidingWindowMaximum<T extends TypedArray = Uint16Array> {\n  private timing: Uint16Array;\n  private values: T;\n  private head: number;\n  private tail: number;\n  private windowSize: number;\n  private time: number;\n\n  constructor(\n    windowSize: number,\n    initialCapacity: number = 1000,\n    ValuesArrayConstructor: Constructor<T> = Uint16Array as any\n  ) {\n    this.windowSize = windowSize;\n    this.timing = new Uint16Array(initialCapacity);\n    this.values = new ValuesArrayConstructor(initialCapacity);\n    this.tail = 0;\n    this.head = 0;\n    this.time = 0;\n  }\n\n  addAndGetMax(value: number): number {\n    this.time++;\n\n    // Remove indices that are outside the window (too old)\n    while (this.timing[this.tail]! <= this.time - this.windowSize && this.head > this.tail) {\n      this.tail++;\n    }\n\n    // Remove indices whose values are smaller than current value\n    while (this.values[this.head - 1]! <= value && this.head > this.tail) {\n      this.head--;\n    }\n\n    // Check if we need to reset before adding\n    if (this.head >= this.timing.length) {\n      this.timing.set(this.timing.subarray(this.tail, this.head), 0);\n      this.values.set(this.values.subarray(this.tail, this.head) as any, 0);\n      this.head = this.head - this.tail;\n      this.tail = 0;\n    }\n\n    // Add current value and timing at head (right side)\n    this.values[this.head] = value;\n    this.timing[this.head] = this.time;\n    this.head++;\n\n    // Return maximum (value at tail)\n    return this.values[this.tail] as any;\n  }\n}\n", "import { BaseGenerator, BaseGeneratorOptions } from '../base-generator/base-generator';\nimport { MinimalCumulativeEnergyMap } from '../minimal-cumulative-energy-map/minimal-cumulative-energy-map';\nimport { SlidingWindowMaximum } from '../../utils/sliding-window-maximum/sliding-window-maximum';\nimport { registerGenerator } from '../generator/generator';\n\ntype PredictiveSpecificOptions = {\n  batchPercentage?: number;\n  minBatchSize?: number;\n};\n\nexport type PredictiveGeneratorOptions = BaseGeneratorOptions & PredictiveSpecificOptions;\n\ntype PredictiveInstanceOptions = BaseGeneratorOptions & Required<PredictiveSpecificOptions>;\n\nconst defaultOptions: Required<PredictiveSpecificOptions> = {\n  batchPercentage: 0.1,\n  minBatchSize: 10,\n};\n\nexport class PredictiveGenerator extends BaseGenerator {\n  protected options: PredictiveInstanceOptions;\n\n  constructor(options: PredictiveGeneratorOptions) {\n    super(options);\n\n    this.options = { ...defaultOptions, ...options };\n  }\n\n  setBatchPercentage(percentage: number): void {\n    this.options.batchPercentage = percentage;\n  }\n\n  async generateSeamBatch(): Promise<void> {\n    const energyMap = await this.energyMapPromise;\n    const originalIndices = energyMap.originalIndices;\n    const currentWidth = energyMap.width;\n    const currentHeight = energyMap.height;\n\n    // Generate bottom-up minimal cumulative energy map\n    const minimalCumulativeEnergyMap = new MinimalCumulativeEnergyMap({\n      energyMap,\n      accumulateUp: true,\n    });\n    const minimalEnergyMapData = minimalCumulativeEnergyMap.minimalEnergyMap;\n\n    // Initialize seams with energies from first row\n    type Seam = {\n      path: Uint16Array;\n      energy: number;\n      slidingWindowMaximum: SlidingWindowMaximum;\n    };\n    const seams: Seam[] = [];\n    const energyMapData = energyMap.energyMap;\n\n    for (let x = 0; x < currentWidth; x++) {\n      const initialEnergy = energyMapData[0]![x]!;\n      seams.push({\n        path: new Uint16Array(currentHeight),\n        energy: initialEnergy,\n        slidingWindowMaximum: new SlidingWindowMaximum(1),\n      });\n      seams[x]!.path[0] = x;\n    }\n\n    // Track which seam is at each position\n    let currentSeamsAtIndex = seams;\n\n    // Process each row after the first\n    for (let y = 1; y < currentHeight; y++) {\n      const nextSeamsAtIndex: Seam[] = [];\n\n      for (let x = 0; x < currentWidth; x++) {\n        const currentSeam = currentSeamsAtIndex[x]!;\n\n        // Last column must go straight\n        if (x === currentWidth - 1) {\n          currentSeam.path[y] = x;\n          currentSeam.energy += currentSeam.slidingWindowMaximum.addAndGetMax(\n            energyMapData[y]![x]!\n          );\n          nextSeamsAtIndex[x] = currentSeam;\n          continue;\n        }\n\n        const nextSeam = currentSeamsAtIndex[x + 1]!;\n\n        // Determine which seam has lower energy\n        const currentSeamLower = currentSeam.energy < nextSeam.energy;\n\n        // Check which path in minimal energy map has lower energy\n        const currentPathLower = minimalEnergyMapData[y]![x]! < minimalEnergyMapData[y]![x + 1]!;\n\n        // If lower seam aligns with lower path, go straight; otherwise swap\n        if (currentSeamLower === currentPathLower) {\n          // Go straight\n          currentSeam.path[y] = x;\n          currentSeam.energy += currentSeam.slidingWindowMaximum.addAndGetMax(\n            energyMapData[y]![x]!\n          );\n          nextSeamsAtIndex[x] = currentSeam;\n        } else {\n          // Swap\n          currentSeam.path[y] = x + 1;\n          currentSeam.energy += currentSeam.slidingWindowMaximum.addAndGetMax(\n            energyMapData[y]![x + 1]!\n          );\n          nextSeamsAtIndex[x + 1] = currentSeam;\n\n          nextSeam.path[y] = x;\n          nextSeam.energy += nextSeam.slidingWindowMaximum.addAndGetMax(energyMapData[y]![x]!);\n          nextSeamsAtIndex[x] = nextSeam;\n\n          // Skip the next position since we processed both seams\n          x++;\n        }\n      }\n\n      currentSeamsAtIndex = nextSeamsAtIndex;\n    }\n\n    // Sort seams by energy\n    seams.sort((a, b) => a.energy - b.energy);\n\n    const batchSize = Math.max(\n      // the '>> 1 << 1' ensures that the batch size is even.\n      (Math.ceil(currentWidth * this.options.batchPercentage) >> 1) << 1,\n      Math.min(this.options.minBatchSize, currentWidth)\n    );\n    const batchSeams = seams.slice(0, batchSize);\n\n    let seamIndex = this.generatedSeams;\n    for (let i = 0; i < batchSeams.length; i++) {\n      const seam = batchSeams[i]!;\n      seam.path.forEach((x, y) => {\n        const originalIndex = originalIndices[y]![x]!;\n        if (this.seamGrid[originalIndex] !== 65535) {\n          throw new Error('Seam overlap detected');\n        }\n        this.seamGrid[originalIndex] = seamIndex;\n      });\n      seamIndex++;\n    }\n\n    energyMap.removeSeams(batchSeams.map((seam) => seam.path));\n    this.generatedSeams += batchSeams.length;\n  }\n}\n\nif (typeof PREDICTIVE_GENERATOR !== 'undefined' && PREDICTIVE_GENERATOR) {\n  registerGenerator('predictive', PredictiveGenerator);\n}\n", "import { RandomGenerator, RandomGeneratorOptions } from '../random-generator/random-generator';\nimport {\n  PredictiveGenerator,\n  PredictiveGeneratorOptions,\n} from '../predictive-generator/predictive-generator';\nimport { name as packageName } from '../../../package.json';\n\nexport type GeneratorType = 'random' | 'predictive';\nexport type GeneratorImpl = RandomGenerator | PredictiveGenerator;\n\nexport type GeneratorOptions =\n  | ({ generator?: 'random' } & RandomGeneratorOptions)\n  | ({ generator: 'predictive' } & PredictiveGeneratorOptions);\n\nconst generatorRegistry = new Map<GeneratorType, new (options: any) => GeneratorImpl>();\n\nexport function registerGenerator(\n  algorithm: GeneratorType,\n  constructor: new (options: any) => GeneratorImpl\n) {\n  Promise.resolve().then(() => {\n    generatorRegistry.set(algorithm, constructor);\n  });\n}\n\nexport function createGenerator(options: GeneratorOptions) {\n  const algorithm = options.generator ?? 'random';\n  const GeneratorConstructor = generatorRegistry.get(algorithm);\n\n  if (!GeneratorConstructor) {\n    throw new Error(\n      `[${packageName}] Generator '${algorithm}' is not registered or included in the build.`\n    );\n  }\n\n  return new GeneratorConstructor(options);\n}\n\n// These will self-register\nimport '../random-generator/random-generator';\nimport '../predictive-generator/predictive-generator';\n", "export class Profiler {\n  #log: (str: string) => void;\n  #times = new Map<\n    string,\n    { startTime: number; minLoggingTime: number; totalNestedTime: number }\n  >();\n  #activeStack: string[] = [];\n\n  constructor(log: (str: string) => void) {\n    this.#log = log;\n  }\n\n  start(name: string, minLoggingTime: number = 0): void {\n    this.#times.set(name, {\n      startTime: performance.now(),\n      minLoggingTime,\n      totalNestedTime: 0,\n    });\n    this.#activeStack.push(name);\n  }\n\n  end(name: string): void {\n    const { startTime, minLoggingTime, totalNestedTime } = this.#times.get(name)!;\n    const elapsedTime = performance.now() - startTime;\n\n    if (elapsedTime < minLoggingTime) return;\n\n    const stackSize = this.#activeStack.length;\n    if (stackSize > 1) {\n      const parentName = this.#activeStack[stackSize - 2]!;\n      const parentData = this.#times.get(parentName)!;\n      parentData.totalNestedTime += elapsedTime;\n    }\n\n    if (totalNestedTime > 0) {\n      this.#log(\n        `${name}: ${(elapsedTime - totalNestedTime).toFixed(2)}ms (${elapsedTime.toFixed(2)}ms)`\n      );\n    } else {\n      this.#log(`${name}: ${(elapsedTime - totalNestedTime).toFixed(2)}ms`);\n    }\n\n    this.#activeStack.pop();\n    this.#times.delete(name);\n  }\n}\n", "export function errorBoundary<T extends (this: any, ...args: any[]) => any>(\n  originalMethod: T\n): (this: ThisParameterType<T>, ...args: Parameters<T>) => ReturnType<T> | void {\n  return function replacementMethod(\n    this: ThisParameterType<T>,\n    ...args: Parameters<T>\n  ): ReturnType<T> | void {\n    if (this.hasFailed) {\n      return;\n    }\n\n    try {\n      const result = originalMethod.apply(this, args);\n      if (result && typeof result.catch === 'function') {\n        return result.catch((error: unknown) => {\n          this.handleFailure(error);\n        });\n      }\n      return result;\n    } catch (error) {\n      this.handleFailure(error);\n    }\n  };\n}\n", "export function toKebabCase(str: string): string {\n  return str.replace(/([A-Z])/g, '-$1').toLowerCase();\n}\n", "import { toKebabCase } from '../to-kebab-case/to-kebab-case';\nimport { name as packageName } from '../../../package.json';\n\nexport const createOptionGetters = <T extends object>(options: T) => {\n  const getConstrainedNumber = (_name: keyof T, defaultValue: number, min = 0, max = 1): number => {\n    const name = String(_name);\n    const value = Number(options[toKebabCase(name) as keyof T] ?? defaultValue);\n    if (value < min || value > max) {\n      throw new Error(`[${packageName}] \\`${name}\\` must be between ${min} and ${max}.`);\n    }\n    return value;\n  };\n\n  const getBoolean = (_name: keyof T, defaultValue: boolean): boolean => {\n    const name = String(_name);\n    const value = options[toKebabCase(name) as keyof T];\n    // HTML boolean attributes: presence = true, absence (null) = false, value is ignored\n    if (value === null) return false; // Explicitly removed attribute\n    return value !== undefined ? true : defaultValue;\n  };\n\n  const getEnumValue = <E extends Record<string, string>>(\n    _name: keyof T,\n    enumObject: E,\n    defaultValue: E[keyof E]\n  ): E[keyof E] => {\n    const name = String(_name);\n    const value = options[toKebabCase(name) as keyof T] as string | undefined | null;\n\n    if (value === null || value === undefined) {\n      return defaultValue;\n    }\n\n    const enumValues = Object.values(enumObject);\n    if (enumValues.includes(value)) {\n      return value as E[keyof E];\n    }\n\n    console.warn(\n      `[${packageName}] Invalid value for ${name}: \"${value}\". Defaulting to \"${defaultValue}\".`\n    );\n    return defaultValue;\n  };\n\n  return { getConstrainedNumber, getBoolean, getEnumValue };\n};\n", "export const ScalingAxis = {\n  Horizontal: 'horizontal',\n  Vertical: 'vertical',\n  Auto: 'auto',\n  Dual: 'dual',\n} as const;\n\nexport type ScalingAxis = (typeof ScalingAxis)[keyof typeof ScalingAxis];\n", "import { ImageLoader } from '../../utils/image-loader/image-loader';\nimport { GeneratorType, SeamPixelPriorityGrid } from '../../utils/types/types';\nimport { createGenerator, GeneratorOptions } from '../../generator/generator/generator';\nimport { Profiler } from '../../utils/profiler/profiler';\nimport { errorBoundary } from '../../utils/error-boundary/error-boundary';\nimport { EnergyMap } from '../../generator/energy-map/energy-map';\nimport { createOptionGetters } from '../../utils/option-helpers/option-helpers';\nimport { ScalingAxis } from '../../utils/enums/enums';\n\nimport { name as packageName } from '../../../package.json';\n\nexport interface SeamGenerator {\n  generateSeamGrid(minSeams: number): Promise<SeamPixelPriorityGrid>;\n  getImage(): Promise<HTMLImageElement>;\n  getImageData(): Promise<ImageData>;\n}\n\ntype GeneralOptions = {\n  generator?: GeneratorType;\n  carvingPriority?: number;\n  maxCarveUpSeamPercentage?: number;\n  maxCarveUpScale?: number;\n  maxCarveDownScale?: number;\n  scalingAxis?: ScalingAxis;\n  width?: number;\n  height?: number;\n  logger?: (message: string) => void;\n  showEnergyMap?: boolean;\n  demoMode?: boolean;\n};\n\ntype SeamOptions = GeneralOptions & GeneratorOptions;\ntype ProcessedSeamOptions = Required<GeneralOptions> & GeneratorOptions;\n\nexport type RendererConfig = {\n  parentNode: HTMLElement;\n  src: string;\n  generator?: GeneratorType;\n  mask?: string;\n} & SeamOptions;\n\nexport class Renderer {\n  private canvas!: HTMLCanvasElement;\n  private ctx!: CanvasRenderingContext2D;\n  private height = 0;\n  private width = 0;\n  private options!: ProcessedSeamOptions;\n  private internalHorizontalGenerator?: SeamGenerator;\n  private internalVerticalGenerator?: SeamGenerator;\n  private currentGenerator!: SeamGenerator;\n  private isVertical!: boolean;\n  private redrawQueued = false;\n  private profiler!: Profiler;\n  private hasFailed = false;\n  private parentNode: HTMLElement;\n  private src: string;\n  private mask?: string;\n  private cachedEnergyMapImageData: ImageData | null = null;\n\n  setOptions = errorBoundary(this._setOptions).bind(this);\n  private redraw = errorBoundary(this._redraw).bind(this);\n\n  constructor(config: RendererConfig) {\n    const { parentNode, src, mask, ...options } = config;\n    this.parentNode = parentNode;\n    this.src = src;\n    this.mask = mask;\n\n    try {\n      this.options = this.validateAndApplyDefaults(options);\n      this.profiler = new Profiler(this.options.logger);\n      this.initializeCanvas(parentNode);\n    } catch (e) {\n      this.handleFailure(e);\n    }\n  }\n\n  destroy(): void {\n    this.canvas.remove();\n  }\n\n  private get horizontalGenerator(): SeamGenerator {\n    if (!this.internalHorizontalGenerator) {\n      const imageLoader = new ImageLoader(this.src, { rotate: false, profiler: this.profiler });\n      const maskLoader = this.mask ? new ImageLoader(this.mask, { rotate: false }) : undefined;\n      this.internalHorizontalGenerator = this.createGenerator({ imageLoader, maskLoader });\n    }\n    return this.internalHorizontalGenerator;\n  }\n\n  private get verticalGenerator(): SeamGenerator {\n    if (!this.internalVerticalGenerator) {\n      const imageLoader = new ImageLoader(this.src, { rotate: true, profiler: this.profiler });\n      const maskLoader = this.mask ? new ImageLoader(this.mask, { rotate: true }) : undefined;\n      this.internalVerticalGenerator = this.createGenerator({ imageLoader, maskLoader });\n    }\n    return this.internalVerticalGenerator;\n  }\n\n  private determineCurrentGenerator(): SeamGenerator {\n    return this.isVertical ? this.verticalGenerator : this.horizontalGenerator;\n  }\n\n  private createGenerator(loaders: {\n    imageLoader: ImageLoader;\n    maskLoader?: ImageLoader;\n  }): SeamGenerator {\n    const options = {\n      ...this.options,\n      imageLoader: loaders.imageLoader,\n      maskLoader: loaders.maskLoader,\n    };\n\n    return createGenerator(options);\n  }\n\n  private validateAndApplyDefaults(options: SeamOptions): ProcessedSeamOptions {\n    const { getBoolean, getConstrainedNumber, getEnumValue } = createOptionGetters(options);\n\n    const newOptions: SeamOptions = {\n      ...options,\n      carvingPriority: getConstrainedNumber('carvingPriority', 1),\n      maxCarveUpSeamPercentage: getConstrainedNumber('maxCarveUpSeamPercentage', 0.6),\n      maxCarveUpScale: getConstrainedNumber('maxCarveUpScale', 10, 1, 10),\n      maxCarveDownScale: getConstrainedNumber('maxCarveDownScale', 1),\n      scalingAxis: getEnumValue('scalingAxis', ScalingAxis, ScalingAxis.Horizontal),\n      logger: options.logger ?? (() => {}),\n      showEnergyMap: getBoolean('showEnergyMap', false),\n      demoMode: getBoolean('demoMode', false),\n    };\n\n    return newOptions as ProcessedSeamOptions;\n  }\n\n  private calculateDimensions(parentNode: HTMLElement): { width: number; height: number } {\n    let { width, height } = this.options;\n    if (width === undefined || height === undefined) {\n      const parentNodeSize = parentNode.getBoundingClientRect();\n      width = width ?? parentNodeSize.width;\n      height = height ?? parentNodeSize.height;\n    }\n\n    return { width, height };\n  }\n\n  private initializeCanvas(parentNode: HTMLElement): void {\n    const { width, height } = this.calculateDimensions(parentNode);\n\n    this.canvas = document.createElement('canvas');\n    this.ctx = this.canvas.getContext('2d')!;\n    this.canvas.width = this.width = width;\n    this.canvas.height = this.height = height;\n    this.canvas.style.display = 'block';\n\n    parentNode.appendChild(this.canvas);\n\n    this.queueRedraw();\n  }\n\n  setSize(width: number, height: number): void {\n    this.width = width;\n    this.height = height;\n    this.queueRedraw();\n  }\n\n  setWidth(width: number): void {\n    this.width = width;\n    this.queueRedraw();\n  }\n\n  setHeight(height: number): void {\n    this.height = height;\n    this.queueRedraw();\n  }\n\n  private _setOptions(options: Partial<SeamOptions>): void {\n    const oldShowEnergyMap = this.options.showEnergyMap;\n\n    this.options = this.validateAndApplyDefaults({\n      ...this.options,\n      ...options,\n    } as SeamOptions);\n\n    // Invalidate energy map cache if showEnergyMap option changed\n    if (this.options.showEnergyMap !== oldShowEnergyMap) {\n      this.cachedEnergyMapImageData = null;\n    }\n\n    this.queueRedraw();\n  }\n\n  private queueRedraw(): void {\n    if (this.redrawQueued) {\n      return;\n    }\n    this.redrawQueued = true;\n\n    Promise.resolve().then(async () => {\n      await this.redraw();\n      this.redrawQueued = false;\n    });\n  }\n\n  // The total number of seams to add or remove.\n  private determineCarvingParameters(imageData: ImageData): {\n    availableSeams: number;\n    interpolationPixels: number;\n    carveDown: boolean;\n  } {\n    const { carvingPriority, maxCarveUpSeamPercentage, maxCarveUpScale, maxCarveDownScale } =\n      this.options;\n    const { width: originalWidth, height: originalHeight } = imageData;\n\n    const { isVertical, width, height } = this;\n    const logicalCanvasWidth = isVertical ? height : width;\n    const logicalCanvasHeight = isVertical ? width : height;\n\n    const targetAspectRatio = logicalCanvasWidth / logicalCanvasHeight;\n    const targetWidth = Math.round(originalHeight * targetAspectRatio);\n    const pixelDelta = originalWidth - targetWidth;\n\n    //\n    if (pixelDelta === 0) {\n      return { availableSeams: 0, interpolationPixels: 0, carveDown: false };\n    }\n\n    const seamsToCalculate = Math.abs(pixelDelta) * carvingPriority;\n    const maxRatio = pixelDelta > 0 ? maxCarveDownScale : maxCarveUpSeamPercentage;\n    const maxSeams = originalWidth * maxRatio;\n    const direction = pixelDelta > 0 ? 1 : -1;\n    const carveDown = pixelDelta > 0;\n\n    const availableSeams = Math.floor(Math.min(seamsToCalculate, maxSeams)) * direction;\n\n    // if shrinking\n    if (carveDown) {\n      return { availableSeams, interpolationPixels: 0, carveDown };\n    } else {\n      // Calculate totalPixelsToInsert based on the effective target width driven by aspect ratio and canvas dimensions,\n      // capped by maxCarveUpScale.\n      const targetEffectiveWidthByRatio = Math.round(\n        (originalHeight / logicalCanvasHeight) * logicalCanvasWidth\n      );\n      const targetPixelsNeeded = targetEffectiveWidthByRatio - originalWidth;\n\n      const maxCarveUpImageDataWidth = Math.floor(originalWidth * maxCarveUpScale);\n      const maxPixelsByScale = maxCarveUpImageDataWidth - originalWidth;\n\n      // The total pixels to insert is the minimum of what's needed for the target ratio, and what's allowed by maxCarveUpScale.\n      const totalPixelsToInsert = Math.max(0, Math.min(targetPixelsNeeded, maxPixelsByScale));\n\n      const interpolationPixels = totalPixelsToInsert;\n\n      return { availableSeams: -availableSeams, interpolationPixels, carveDown };\n    }\n  }\n\n  private async determineOrientation(): Promise<boolean> {\n    if (this.options.scalingAxis === ScalingAxis.Horizontal) return false;\n    if (this.options.scalingAxis === ScalingAxis.Vertical) return true;\n\n    const { width: imageWidth, height: imageHeight } = await this.horizontalGenerator.getImage();\n    const originalAspectRatio = imageWidth / imageHeight;\n    const targetAspectRatio = this.width / this.height;\n\n    return targetAspectRatio > originalAspectRatio;\n  }\n\n  private async refreshCachedArgs(): Promise<void> {\n    this.isVertical = await this.determineOrientation();\n    this.currentGenerator = this.determineCurrentGenerator();\n  }\n\n  private async getEnergyMapImageData(): Promise<ImageData> {\n    if (this.cachedEnergyMapImageData) {\n      return this.cachedEnergyMapImageData;\n    }\n\n    const originalImageData = await this.currentGenerator.getImageData();\n    const energyMap = new EnergyMap({ imageData: originalImageData });\n    this.cachedEnergyMapImageData = energyMap.getEnergyMapAsImageData();\n\n    return this.cachedEnergyMapImageData;\n  }\n\n  private async getSourceImageData(): Promise<ImageData> {\n    if (this.options.showEnergyMap) {\n      return await this.getEnergyMapImageData();\n    } else {\n      return await this.currentGenerator.getImageData();\n    }\n  }\n\n  private async _redraw(): Promise<void> {\n    if (!this.width || !this.height) return;\n\n    this.profiler.start('redraw');\n\n    await this.refreshCachedArgs();\n    const originalImageData = await this.getSourceImageData();\n\n    const { availableSeams, interpolationPixels, carveDown } =\n      this.determineCarvingParameters(originalImageData);\n\n    let finalImageData: ImageData;\n\n    if (availableSeams === 0) {\n      finalImageData = originalImageData;\n    } else {\n      this.profiler.start('generateSeamGrid', 1);\n      const seamGrid = await this.currentGenerator.generateSeamGrid(Math.abs(availableSeams));\n      this.profiler.end('generateSeamGrid');\n\n      if (carveDown) {\n        finalImageData = this.filterPixels(originalImageData, seamGrid, availableSeams);\n      } else {\n        finalImageData = this.interpolatePixels(\n          originalImageData,\n          seamGrid,\n          availableSeams,\n          interpolationPixels\n        );\n      }\n    }\n\n    this.canvas.width = finalImageData.width;\n    this.canvas.height = finalImageData.height;\n    this.ctx.putImageData(finalImageData, 0, 0);\n\n    const styleRef = this.canvas.style;\n    const { isVertical, width, height } = this;\n\n    styleRef.transformOrigin = '0 0';\n    styleRef.transform = isVertical ? 'rotate(-90deg) translateX(-100%)' : '';\n\n    styleRef.width = `${isVertical ? height : width}px`;\n    styleRef.height = `${isVertical ? width : height}px`;\n\n    this.profiler.end('redraw');\n  }\n\n  private interpolatePixels(\n    originalImageData: ImageData,\n    seamGrid: SeamPixelPriorityGrid,\n    seamsAvailable: number,\n    totalPixelsToInsert: number\n  ): ImageData {\n    const { width: originalWidth, height, data: originalData } = originalImageData;\n    const newWidth = originalWidth + totalPixelsToInsert;\n    const newSize = newWidth * height * 4;\n    const newData = new Uint8ClampedArray(newSize);\n    let writeIndex = 0;\n    const numPixels = originalData.length / 4;\n\n    const basePixelsPerLocation = Math.floor(totalPixelsToInsert / seamsAvailable);\n    const extraPixelsCount = totalPixelsToInsert % seamsAvailable;\n\n    let x = 0;\n    for (let readIndex = 0; readIndex < numPixels; readIndex++) {\n      const priority = seamGrid[readIndex]!;\n      const readIndexRgba = readIndex * 4;\n\n      // If this pixel is a seam to be \"inserted\", add an interpolated pixel first.\n      if (priority < seamsAvailable) {\n        // Determine how many pixels to interpolate for *this specific seam*\n        // To interlace the extra pixels, we distribute them based on a calculated pattern\n        // rather than front-loading them to the lowest priority indices.\n        const addExtraPixel =\n          extraPixelsCount > 0 && (priority * extraPixelsCount) % seamsAvailable < extraPixelsCount;\n\n        const pixelsToInterpolate = addExtraPixel\n          ? basePixelsPerLocation + 1\n          : basePixelsPerLocation;\n\n        if (x === 0) {\n          // First column, just duplicate the pixel\n          for (let i = 0; i < pixelsToInterpolate; i++) {\n            newData[writeIndex] = originalData[readIndexRgba]!;\n            newData[writeIndex + 1] = originalData[readIndexRgba + 1]!;\n            newData[writeIndex + 2] = originalData[readIndexRgba + 2]!;\n            newData[writeIndex + 3] = originalData[readIndexRgba + 3]!;\n            writeIndex += 4;\n          }\n        } else {\n          // Interpolate with the pixel to the left\n          const leftReadIndexRgba = (readIndex - 1) * 4;\n\n          const r0 = originalData[leftReadIndexRgba]!;\n          const g0 = originalData[leftReadIndexRgba + 1]!;\n          const b0 = originalData[leftReadIndexRgba + 2]!;\n          const a0 = originalData[leftReadIndexRgba + 3]!;\n\n          const dr = originalData[readIndexRgba]! - r0;\n          const dg = originalData[readIndexRgba + 1]! - g0;\n          const db = originalData[readIndexRgba + 2]! - b0;\n          const da = originalData[readIndexRgba + 3]! - a0;\n\n          const denominator = pixelsToInterpolate + 1;\n          for (let i = 0; i < pixelsToInterpolate; i++) {\n            // Calculate interpolation factor for the current interpolated pixel\n            const interpolationFactor = (i + 1) / denominator;\n\n            newData[writeIndex] = Math.round(r0 + dr * interpolationFactor);\n            newData[writeIndex + 1] = Math.round(g0 + dg * interpolationFactor);\n            newData[writeIndex + 2] = Math.round(b0 + db * interpolationFactor);\n            newData[writeIndex + 3] = Math.round(a0 + da * interpolationFactor);\n            writeIndex += 4;\n          }\n        }\n      }\n\n      // Always write the original pixel\n      newData[writeIndex] = originalData[readIndexRgba]!;\n      newData[writeIndex + 1] = originalData[readIndexRgba + 1]!;\n      newData[writeIndex + 2] = originalData[readIndexRgba + 2]!;\n      newData[writeIndex + 3] = originalData[readIndexRgba + 3]!;\n      writeIndex += 4;\n\n      if (++x === originalWidth) {\n        x = 0;\n      }\n    }\n\n    if (writeIndex !== newSize) {\n      console.error(\n        `[${packageName}] Mismatch during interpolation. Wrote ${writeIndex} bytes but expected ${newSize}.`\n      );\n    }\n\n    return new ImageData(newData, newWidth, height);\n  }\n\n  private filterPixels(\n    originalImageData: ImageData,\n    seamGrid: SeamPixelPriorityGrid,\n    seamsToRemove: number\n  ): ImageData {\n    const { width: originalWidth, height, data: originalData } = originalImageData;\n    const newWidth = originalWidth - seamsToRemove;\n    const newSize = newWidth * height * 4;\n    const newData = new Uint8ClampedArray(newSize);\n    const numPixels = originalData.length / 4;\n    let writeIndex = 0;\n\n    for (let readIndex = 0; readIndex < numPixels; readIndex++) {\n      const priority = seamGrid[readIndex]!;\n\n      if (priority >= seamsToRemove) {\n        const readIndexRgba = readIndex * 4;\n\n        newData[writeIndex] = originalData[readIndexRgba]!;\n        newData[writeIndex + 1] = originalData[readIndexRgba + 1]!;\n        newData[writeIndex + 2] = originalData[readIndexRgba + 2]!;\n        newData[writeIndex + 3] = originalData[readIndexRgba + 3]!;\n\n        writeIndex += 4;\n      }\n    }\n\n    if (writeIndex !== newSize) {\n      console.error(\n        `[${packageName}] Mismatch in pixel buffer size. Expected ${newSize}, but got ${writeIndex}.`\n      );\n    }\n\n    return new ImageData(newData, newWidth, height);\n  }\n\n  private handleFailure(error: unknown): void {\n    if (this.hasFailed) return;\n\n    this.hasFailed = true;\n\n    console.error(`[${packageName}] A critical error occurred. Falling back to <img>.`, error);\n\n    this.canvas?.remove();\n\n    const img = document.createElement('img');\n\n    img.src = this.src;\n    img.style.width = '100%';\n    img.style.height = '100%';\n    img.style.display = 'block';\n\n    this.parentNode.appendChild(img);\n  }\n}\n", "import { Renderer, RendererConfig } from '../renderer/renderer';\nimport { ScalingAxis } from '../../utils/enums/enums';\nimport { toKebabCase } from '../../utils/to-kebab-case/to-kebab-case';\n\ntype SeamAttributes = Omit<RendererConfig, 'parentNode' | 'src' | 'width' | 'height' | 'logger'>;\n\nexport class FluidImg extends HTMLElement {\n  private renderer: Renderer | null = null;\n  private resizeObserver: ResizeObserver | null = null;\n  private intersectionObserver: IntersectionObserver | null = null;\n  private updateQueue = new Set<string>();\n  private isIntersecting = false;\n  private storedDimensions: { width: number; height: number } | null = null;\n  private options: Record<string, string | number | boolean> = {};\n\n  private static readonly destructiveProperties = new Set([\n    'src',\n    'scaling-axis',\n    'mask',\n    'generator',\n  ]);\n\n  constructor() {\n    super();\n  }\n\n  static get observedAttributes(): Array<\n    keyof SeamAttributes | 'src' | 'mask' | 'on-screen-threshold'\n  > {\n    const seamAttributes: Array<keyof SeamAttributes> = [\n      'generator',\n      'carvingPriority',\n      'maxCarveUpSeamPercentage',\n      'maxCarveUpScale',\n      'maxCarveDownScale',\n      'scalingAxis',\n      'showEnergyMap',\n      'mask',\n    ];\n\n    const kebabCaseAttributes = seamAttributes.map(toKebabCase);\n\n    return ['src', 'mask', 'on-screen-threshold', ...kebabCaseAttributes] as any;\n  }\n\n  connectedCallback(): void {\n    this.setupResizeObserver();\n    this.setupIntersectionObserver();\n  }\n\n  disconnectedCallback(): void {\n    this.renderer?.destroy();\n    this.renderer = null;\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = null;\n    this.intersectionObserver?.disconnect();\n    this.intersectionObserver = null;\n  }\n\n  attributeChangedCallback(name: string, oldValue: string | null, newValue: string | null): void {\n    if (oldValue === newValue) return;\n\n    if (!this.updateQueue.size) {\n      setTimeout(this.processUpdates);\n    }\n\n    this.updateQueue.add(name);\n  }\n\n  private processUpdates = (): void => {\n    const changes = Array.from(this.updateQueue);\n    this.updateQueue.clear();\n\n    if (changes.some((change) => FluidImg.destructiveProperties.has(change))) {\n      this.renderer?.destroy();\n      this.renderer = null;\n      this.initializeRenderer();\n      return;\n    }\n\n    if (changes.includes('on-screen-threshold')) {\n      this.setupIntersectionObserver();\n    }\n\n    if (!this.renderer) return;\n\n    const otherOptions = changes.reduce(\n      (acc, key) => {\n        if (key !== 'src' && key !== 'on-screen-threshold') {\n          const value = this.getAttribute(key);\n          acc[key] = value;\n        }\n        return acc;\n      },\n      {} as Record<string, string | null>\n    );\n\n    this.renderer.setOptions(otherOptions);\n  };\n\n  private dispatchLogEvent = (message: string): void => {\n    const event = new CustomEvent('log', {\n      detail: { message },\n      bubbles: true,\n      composed: true,\n    });\n    this.dispatchEvent(event);\n  };\n\n  private initializeRenderer(): void {\n    if (this.renderer) {\n      return;\n    }\n\n    const options = this.getOptions();\n    this.renderer = new Renderer({\n      parentNode: this,\n      logger: this.dispatchLogEvent,\n      ...options,\n    });\n  }\n\n  private calculateDimensions() {\n    const width = this.clientWidth ?? 100;\n    const height = this.clientHeight ?? 100;\n\n    return { width, height };\n  }\n\n  private getOptions(): any {\n    const options: Record<string, any> = {};\n    for (const attr of FluidImg.observedAttributes) {\n      const kebabCaseAttr = toKebabCase(attr);\n      if (this.hasAttribute(kebabCaseAttr)) {\n        const value = this.getAttribute(kebabCaseAttr);\n        options[attr] = { '': true, true: true, false: false }[value + ''] ?? value;\n      }\n    }\n    return options;\n  }\n\n  private setupResizeObserver(): void {\n    if (!this.parentElement) return;\n\n    this.resizeObserver = new ResizeObserver(() => {\n      const dimensions = this.calculateDimensions();\n\n      this.storedDimensions = dimensions;\n      this.attemptSetSize();\n    });\n\n    this.resizeObserver.observe(this);\n  }\n\n  private setupIntersectionObserver(): void {\n    this.intersectionObserver?.disconnect();\n\n    const threshold = this.getAttribute('on-screen-threshold') || '50px';\n    this.intersectionObserver = new IntersectionObserver(\n      (entries) => {\n        for (const entry of entries) {\n          this.isIntersecting = entry.isIntersecting;\n          if (this.isIntersecting) {\n            this.attemptSetSize();\n          }\n        }\n      },\n      {\n        rootMargin: `${threshold} ${threshold} ${threshold} ${threshold}`,\n      }\n    );\n\n    this.intersectionObserver.observe(this);\n  }\n\n  private attemptSetSize(): void {\n    if (!this.isIntersecting || !this.storedDimensions) return;\n\n    this.renderer?.setSize(this.storedDimensions.width, this.storedDimensions.height);\n    this.storedDimensions = null;\n  }\n\n  get maxCarveUpScale(): number {\n    return this.options['max-carve-up-scale'] as number;\n  }\n  set maxCarveUpScale(value: number) {\n    this.options['max-carve-up-scale'] = value;\n    this.renderer?.setOptions({ maxCarveUpScale: value });\n  }\n\n  get scalingAxis(): ScalingAxis {\n    return this.options['scaling-axis'] as ScalingAxis;\n  }\n  set scalingAxis(value: ScalingAxis) {\n    this.options['scaling-axis'] = value;\n    this.renderer?.setOptions({ scalingAxis: value });\n  }\n\n  get showEnergyMap(): boolean {\n    return this.options['show-energy-map'] as boolean;\n  }\n  set showEnergyMap(value: boolean) {\n    this.options['show-energy-map'] = value;\n    this.renderer?.setOptions({ showEnergyMap: value });\n  }\n\n  get onScreenThreshold(): number {\n    const threshold = this.getAttribute('on-screen-threshold') || '50px';\n    return parseInt(threshold.replace('px', ''), 10);\n  }\n}\n\ncustomElements.define('fluid-img', FluidImg);\n"],
  "mappings": "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",
  "names": ["EvenWidthImage", "#rotate", "options", "originalWidth", "ImageLoader", "#src", "#imgPromise", "#imageDataPromise", "#profiler", "src", "#loadImage", "img", "#loadImageData", "resolve", "reject", "image", "profiler", "context", "imageData", "name", "deleteArrayIndices", "array", "uniqueSortedIndicesToRemove", "elementsPerRemoval", "newSize", "ArrayConstructor", "result", "resultOffset", "sourceStart", "lastIndex", "deleteIndex", "chunkSize", "getGrayscaleImageData", "imageData", "asRows", "useLinearApproximation", "data", "width", "height", "grayscaleData", "y", "rowOffset", "currentArray", "x", "ix", "r", "g", "b", "a", "gray", "SobelEnergyMap", "#data", "#width", "#height", "#grayscaleMap", "#originalIndices", "#maskData", "options", "getGrayscaleImageData", "#fillOriginalIndices", "#computeFullEnergyMap", "#getMaskEnergy", "y", "x", "originalIndex", "width", "height", "energyMapData", "y1", "y3", "prevRow", "currentRow", "nextRow", "x1", "x3", "gx", "gy", "sobelEnergy", "maskEnergy", "xIndices", "xToRemove", "deleteArrayIndices", "g", "colInNewCoord", "removedOriginalIndex", "removedColOrigIdx", "columnsInNewDataToUpdate", "xCurrent", "xCenter", "seams", "numSeamsToRemove", "indicesToRemoveForRow", "seamPath", "a", "b", "minEnergy", "maxEnergy", "energy", "energyRange", "imageData", "data", "index", "normalizedEnergy", "registerEnergyMap", "energyMapRegistry", "registerEnergyMap", "algorithm", "constructor", "createEnergyMap", "options", "EnergyMapConstructor", "name", "EnergyMap", "options", "createEnergyMap", "xIndices", "seams", "width", "height", "BaseGenerator", "options", "imageData", "maskData", "EnergyMap", "getGrayscaleImageData", "minSeams", "width", "cumulativeEnergyMapDefaultOptions", "MinimalCumulativeEnergyMap", "#options", "#minimalEnergyMap", "#width", "#height", "options", "energyMap", "constrainTo16Bit", "constrainToDiagonals", "accumulateUp", "width", "height", "minimalEnergyMap", "startingRow", "endingRow", "increment", "divisor", "shiftAmount", "energyMapData", "row", "col", "energy", "prevLeftEnergy", "prevRightEnergy", "prevStraightEnergy", "minEnergy", "seams", "y", "indicesToRemoveForRow", "seamPath", "a", "b", "deleteArrayIndices", "SlidingWindowMaximum", "windowSize", "initialCapacity", "ValuesArrayConstructor", "value", "defaultOptions", "PredictiveGenerator", "BaseGenerator", "options", "percentage", "energyMap", "originalIndices", "currentWidth", "currentHeight", "minimalEnergyMapData", "MinimalCumulativeEnergyMap", "seams", "energyMapData", "x", "initialEnergy", "SlidingWindowMaximum", "currentSeamsAtIndex", "y", "nextSeamsAtIndex", "currentSeam", "nextSeam", "currentSeamLower", "currentPathLower", "a", "b", "batchSize", "batchSeams", "seamIndex", "i", "originalIndex", "seam", "registerGenerator", "generatorRegistry", "registerGenerator", "algorithm", "constructor", "createGenerator", "options", "GeneratorConstructor", "name", "Profiler", "#log", "#times", "#activeStack", "log", "name", "minLoggingTime", "startTime", "totalNestedTime", "elapsedTime", "stackSize", "parentName", "parentData", "errorBoundary", "originalMethod", "args", "result", "error", "toKebabCase", "str", "createOptionGetters", "options", "_name", "defaultValue", "min", "max", "name", "value", "toKebabCase", "enumObject", "ScalingAxis", "Renderer", "errorBoundary", "config", "parentNode", "src", "mask", "options", "Profiler", "e", "imageLoader", "ImageLoader", "maskLoader", "loaders", "createGenerator", "getBoolean", "getConstrainedNumber", "getEnumValue", "createOptionGetters", "ScalingAxis", "width", "height", "parentNodeSize", "oldShowEnergyMap", "imageData", "carvingPriority", "maxCarveUpSeamPercentage", "maxCarveUpScale", "maxCarveDownScale", "originalWidth", "originalHeight", "isVertical", "logicalCanvasWidth", "logicalCanvasHeight", "targetAspectRatio", "targetWidth", "pixelDelta", "seamsToCalculate", "maxRatio", "maxSeams", "direction", "carveDown", "availableSeams", "targetPixelsNeeded", "maxPixelsByScale", "interpolationPixels", "imageWidth", "imageHeight", "originalAspectRatio", "originalImageData", "energyMap", "EnergyMap", "finalImageData", "seamGrid", "styleRef", "seamsAvailable", "totalPixelsToInsert", "originalData", "newWidth", "newSize", "newData", "writeIndex", "numPixels", "basePixelsPerLocation", "extraPixelsCount", "x", "readIndex", "priority", "readIndexRgba", "pixelsToInterpolate", "i", "leftReadIndexRgba", "r0", "g0", "b0", "a0", "dr", "dg", "db", "da", "denominator", "interpolationFactor", "name", "seamsToRemove", "error", "img", "FluidImg", "_FluidImg", "toKebabCase", "name", "oldValue", "newValue", "changes", "change", "otherOptions", "acc", "key", "value", "message", "event", "options", "Renderer", "width", "height", "attr", "kebabCaseAttr", "dimensions", "threshold", "entries", "entry"]
}
