var F=class extends Image{#e;constructor(e={}){super(),this.crossOrigin="Anonymous",this.#e=!!e.rotate}get width(){let e=this.#e?super.height:super.width;return e-e%2}get height(){return this.#e?super.width:super.height}},x=class{#e;#t;#r;#n;#a;constructor(e,t){this.#e=e,this.#n=t.rotate,this.#a=t.profiler,this.#t=this.#i(),this.#r=this.#t.then(r=>this.#s(r))}#i(){return new Promise((e,t)=>{let r=this.#e,n=new F({rotate:this.#n});n.onload=()=>e(n),n.onerror=()=>t(`Failed to load image: ${r}`),n.onabort=()=>t(`Image loading aborted: ${r}`),n.src=r})}#s(e){let t=this.#a;return new Promise(r=>{t?.start("loadImageData");let i=new OffscreenCanvas(e.width,e.height).getContext("2d");this.#n&&(i.translate(e.width,0),i.rotate(Math.PI/2)),i.drawImage(e,0,0);let s=i.getImageData(0,0,e.width,e.height);t?.end("loadImageData"),r(s)})}get src(){return this.#e}get image(){return this.#t}get imageData(){return this.#r}};var M="fluid-img";var Q=d=>e=>{let t=d^e;return t^=t>>>16,t*=2246822507,t^=t>>>13,t*=3266489909,t^=t>>>16,t&1};function E(d,e,t=1){let r=d.length-e.length*t,n=d.constructor,i=new n(r),s=0,a=0,c=-1;for(let o of e){if(c===o)throw new Error("[deleteArrayIndices]: Duplicate index detected");if(c>o)throw new Error("[deleteArrayIndices]: Indices are not sorted");let h=o-a;h>0&&(i.set(d.subarray(a,o),s),s+=h),a=o+t,c=o}return a<d.length&&i.set(d.subarray(a),s),i}function R(d,e,t=!1){let{data:r,width:n,height:i}=d,s=e?new Array(i):new Uint8Array(n*i);for(let a=0;a<i;a++){let c=a*n,o=e?s[a]=new Uint8Array(n):s;for(let h=0;h<n;h++){let m=(c+h)*4,y=r[m],g=r[m+1],p=r[m+2],l=r[m+3],u;t?u=(y+g+p)/3*l/255:u=(.299*y+.587*g+.114*p)*l/255,o[e?h:c+h]=u}}return s}var T=class{#e;#t;#r;#n;#a;#i;constructor(e){this.#t=e.imageData.width,this.#r=e.imageData.height,this.#e=new Array(this.#r),this.#a=new Array(this.#r),this.#i=e.maskData,this.#n=R(e.imageData,!0),this.#h(),this.#e=this.#o()}#s(e,t){if(!this.#i)return 255;let r=this.#a[e][t];return this.#i[r]}#h(){for(let e=0;e<this.#r;e++){this.#a[e]=new Uint32Array(this.#t);for(let t=0;t<this.#t;t++)this.#a[e][t]=e*this.#t+t}}#o(e=this.#t,t=this.#r){let r=new Array(t);for(let n=0;n<t;n++){r[n]=new Uint16Array(e);let i=Math.max(0,n-1),s=Math.min(t-1,n+1),a=this.#n[i],c=this.#n[n],o=this.#n[s];for(let h=0;h<e;h++){let m=Math.max(0,h-1),y=Math.min(e-1,h+1),g=-a[m]+a[y]+-c[m]*2+c[y]*2+-o[m]+o[y],p=-a[m]+-a[h]*2+-a[y]+o[m]+o[h]*2+o[y],l=(g<0?-g:g)+(p<0?-p:p),u=this.#s(n,h);r[n][h]=l*(u/255)}}return r}get width(){return this.#t}get height(){return this.#r}get energyMap(){return this.#e}get originalIndices(){return this.#a}removeSeam(e){for(let r=0;r<this.#r;r++){let n=e[r];this.#e[r]=E(this.#e[r],[n]),this.#a[r]=E(this.#a[r],[n])}this.#t--;let t=(r,n)=>r<n?r:r+1;for(let r=0;r<this.#r;r++){let n=e[r],i=Math.max(0,r-1),s=Math.min(this.#r-1,r+1),a=this.#n[i],c=this.#n[r],o=this.#n[s],h=[];n>0&&h.push(n-1),n<this.#t&&h.push(n);for(let m of h){let y=Math.max(0,t(m-1,n)),g=Math.min(this.#n[0].length-1,t(m+1,n)),p=t(m,n),l=-a[y]+a[g]+-c[y]*2+c[g]*2+-o[y]+o[g],u=-a[y]+-a[p]*2+-a[g]+o[y]+o[p]*2+o[g],b=(l<0?-l:l)+(u<0?-u:u),f=this.#s(r,m);this.#e[r][m]=b+f}}}removeSeams(e){if(e.length===0)return;let t=e.length;for(let r=0;r<this.#r;r++){let n=e.map(i=>i[r]).sort((i,s)=>i-s);this.#e[r]=E(this.#e[r],n),this.#n[r]=E(this.#n[r],n),this.#a[r]=E(this.#a[r],n)}this.#t-=t,this.#e=this.#o()}getEnergyMapAsImageData(e=this.#t,t=this.#r){let r=this.#o(e,t),n=1/0,i=0;for(let o=0;o<t;o++)for(let h=0;h<e;h++){let m=r[o][h];m<n&&(n=m),m>i&&(i=m)}let s=i-n,a=new ImageData(e,t),c=a.data;for(let o=0;o<t;o++)for(let h=0;h<e;h++){let m=(o*e+h)*4,y=r[o][h],g=s>0?Math.round((y-n)/s*255):0;c[m]=g,c[m+1]=g,c[m+2]=g,c[m+3]=255}return a}};X("sobel",T);var K=new Map;function X(d,e){Promise.resolve().then(()=>{K.set(d,e)})}function Z(d){let e=d.algorithm??"sobel",t=K.get(e);if(!t)throw new Error(`[${M}] Energy map algorithm '${e}' is not registered or included in the build.`);return new t(d)}var C=class{impl;constructor(e){this.impl=Z(e)}get width(){return this.impl.width}get height(){return this.impl.height}get energyMap(){return this.impl.energyMap}get originalIndices(){return this.impl.originalIndices}removeSeam(e){return this.impl.removeSeam(e)}removeSeams(e){return this.impl.removeSeams(e)}getEnergyMapAsImageData(e,t){return this.impl.getEnergyMapAsImageData(e,t)}};var I=class{imageLoader;maskLoader;energyMapPromise;seamGrid=new Uint16Array;generatedSeams=0;constructor(e){this.imageLoader=e.imageLoader,this.maskLoader=e.maskLoader,this.energyMapPromise=this.createEnergyMap()}async getImageData(){return this.imageLoader.imageData}async getImage(){return this.imageLoader.image}async createEnergyMap(){let e=await this.imageLoader.imageData,t=await this.getMaskData();return this.seamGrid=new Uint16Array(e.width*e.height).fill(65535),new C({imageData:e,maskData:t})}async getMaskData(){if(!this.maskLoader)return;let e=await this.maskLoader.imageData;return R(e,!1)}async generateSeamGrid(e){let{width:t}=await this.imageLoader.image;if(t<e)throw new Error(`Cannot generate ${e} seams for image with width ${t}`);for(;this.generatedSeams<e;)await this.generateSeamBatch();return this.seamGrid}};var se={batchPercentage:.05,minBatchSize:10},_=class extends I{connections=[];options;constructor(e){super(e),this.options={...se,...e}}setBatchPercentage(e){this.options.batchPercentage=e}async generateSeamBatch(){let e=await this.energyMapPromise,t=e.originalIndices,r=e.width,n=e.height;this.generateConnections(r,n);let i=Array.from({length:r},(o,h)=>this.getSeam(e,h));i.sort((o,h)=>o.energy-h.energy);let s=Math.max(Math.ceil(r*this.options.batchPercentage)>>1<<1,Math.min(this.options.minBatchSize,r)),a=i.slice(0,s),c=this.generatedSeams;for(let o=0;o<a.length;o++)a[o].seam.forEach((m,y)=>{let g=t[y][m];if(this.seamGrid[g]!==65535)throw new Error("Seam overlap detected");this.seamGrid[g]=c}),c++;e.removeSeams(a.map(o=>o.seam)),this.generatedSeams+=a.length}generateConnections(e,t){let r=Q(e*t+1);this.connections=Array.from({length:t},()=>new Int8Array(e));let n=e-1;for(let i=0;i<t;i++)for(let s=0;s<e;s++)s===n||r(i*e+s)?this.connections[i][s]=0:(this.connections[i][s]=1,this.connections[i][s+1]=-1,s++)}getSeam(e,t){let r=e.height,n=new Uint16Array(r),i=e.energyMap,s=0,a=t;for(let c=0;c<r;c++)n[c]=a=a+this.connections[c][a],s+=i[c][a];return{seam:n,energy:s}}};U("random",_);var oe={constrainTo16Bit:!1,constrainToDiagonals:!1,accumulateUp:!1},k=class{#e;#t;#r;#n;constructor(e){this.#e={...oe,...e},this.#r=e.energyMap.width,this.#n=e.energyMap.height,this.#t=this.computeMinimalEnergyMap()}computeMinimalEnergyMap(){let{energyMap:e,constrainTo16Bit:t,constrainToDiagonals:r,accumulateUp:n}=this.#e,{width:i,height:s}=e,a=new Array(s),c=n?s-1:0,o=n?-1:s,h=n?-1:1,m=t?s/256:1,y=t?Math.ceil(Math.log2(m)):0,g=e.energyMap;a[c]=new(t?Uint16Array:Uint32Array)(g[c]);for(let p=c+h;p!==o;p+=h){a[p]=new(t?Uint16Array:Uint32Array)(i);for(let l=0;l<i;l++){let u=g[p][l],b=a[p-h][l-1]??1/0,f=a[p-h][l+1]??1/0,D=r?1/0:a[p-h][l],w=Math.min(b,f,D);a[p][l]=u+w>>y}}return a}removeSeams(e){if(e.length!==0){for(let t=0;t<this.#n;t++){let r=e.map(n=>n[t]).sort((n,i)=>n-i);this.#t[t]=E(this.#t[t],r)}this.#r-=e.length}}get minimalEnergyMap(){return this.#t}};var L=class{timing;values;head;tail;windowSize;time;constructor(e,t=1e3,r=Uint16Array){this.windowSize=e,this.timing=new Uint16Array(t),this.values=new r(t),this.tail=0,this.head=0,this.time=0}addAndGetMax(e){for(this.time++;this.timing[this.tail]<=this.time-this.windowSize&&this.head>this.tail;)this.tail++;for(;this.values[this.head-1]<=e&&this.head>this.tail;)this.head--;return this.head>=this.timing.length&&(this.timing.set(this.timing.subarray(this.tail,this.head),0),this.values.set(this.values.subarray(this.tail,this.head),0),this.head=this.head-this.tail,this.tail=0),this.values[this.head]=e,this.timing[this.head]=this.time,this.head++,this.values[this.tail]}};var he={batchPercentage:.1,minBatchSize:10},H=class extends I{options;constructor(e){super(e),this.options={...he,...e}}setBatchPercentage(e){this.options.batchPercentage=e}async generateSeamBatch(){let e=await this.energyMapPromise,t=e.originalIndices,r=e.width,n=e.height,s=new k({energyMap:e,accumulateUp:!0}).minimalEnergyMap,a=[],c=e.energyMap;for(let g=0;g<r;g++){let p=c[0][g];a.push({path:new Uint16Array(n),energy:p,slidingWindowMaximum:new L(1)}),a[g].path[0]=g}let o=a;for(let g=1;g<n;g++){let p=[];for(let l=0;l<r;l++){let u=o[l];if(l===r-1){u.path[g]=l,u.energy+=u.slidingWindowMaximum.addAndGetMax(c[g][l]),p[l]=u;continue}let b=o[l+1],f=u.energy<b.energy,D=s[g][l]<s[g][l+1];f===D?(u.path[g]=l,u.energy+=u.slidingWindowMaximum.addAndGetMax(c[g][l]),p[l]=u):(u.path[g]=l+1,u.energy+=u.slidingWindowMaximum.addAndGetMax(c[g][l+1]),p[l+1]=u,b.path[g]=l,b.energy+=b.slidingWindowMaximum.addAndGetMax(c[g][l]),p[l]=b,l++)}o=p}a.sort((g,p)=>g.energy-p.energy);let h=Math.max(Math.ceil(r*this.options.batchPercentage)>>1<<1,Math.min(this.options.minBatchSize,r)),m=a.slice(0,h),y=this.generatedSeams;for(let g=0;g<m.length;g++)m[g].path.forEach((l,u)=>{let b=t[u][l];if(this.seamGrid[b]!==65535)throw new Error("Seam overlap detected");this.seamGrid[b]=y}),y++;e.removeSeams(m.map(g=>g.path)),this.generatedSeams+=m.length}};U("predictive",H);var J=new Map;function U(d,e){Promise.resolve().then(()=>{J.set(d,e)})}function ee(d){let e=d.generator??"random",t=J.get(e);if(!t)throw new Error(`[${M}] Generator '${e}' is not registered or included in the build.`);return new t(d)}var z=class{#e;#t=new Map;#r=[];constructor(e){this.#e=e}start(e,t=0){this.#t.set(e,{startTime:performance.now(),minLoggingTime:t,totalNestedTime:0}),this.#r.push(e)}end(e){let{startTime:t,minLoggingTime:r,totalNestedTime:n}=this.#t.get(e),i=performance.now()-t;if(i<r)return;let s=this.#r.length;if(s>1){let a=this.#r[s-2],c=this.#t.get(a);c.totalNestedTime+=i}n>0?this.#e(`${e}: ${(i-n).toFixed(2)}ms (${i.toFixed(2)}ms)`):this.#e(`${e}: ${(i-n).toFixed(2)}ms`),this.#r.pop(),this.#t.delete(e)}};function q(d){return function(...t){if(!this.hasFailed)try{let r=d.apply(this,t);return r&&typeof r.catch=="function"?r.catch(n=>{this.handleFailure(n)}):r}catch(r){this.handleFailure(r)}}}function A(d){return d.replace(/([A-Z])/g,"-$1").toLowerCase()}var te=d=>({getConstrainedNumber:(n,i,s=0,a=1)=>{let c=String(n),o=Number(d[A(c)]??i);if(o<s||o>a)throw new Error(`[${M}] \`${c}\` must be between ${s} and ${a}.`);return o},getBoolean:(n,i)=>{let s=String(n),a=d[A(s)];return a===null?!1:a!==void 0?!0:i},getEnumValue:(n,i,s)=>{let a=String(n),c=d[A(a)];return c==null?s:Object.values(i).includes(c)?c:(console.warn(`[${M}] Invalid value for ${a}: "${c}". Defaulting to "${s}".`),s)}});var S={Horizontal:"horizontal",Vertical:"vertical",Auto:"auto",Dual:"dual"};var B=class{canvas;ctx;height=0;width=0;options;internalHorizontalGenerator;internalVerticalGenerator;currentGenerator;isVertical;redrawQueued=!1;profiler;hasFailed=!1;parentNode;src;mask;cachedEnergyMapImageData=null;setOptions=q(this._setOptions).bind(this);redraw=q(this._redraw).bind(this);constructor(e){let{parentNode:t,src:r,mask:n,...i}=e;this.parentNode=t,this.src=r,this.mask=n;try{this.options=this.validateAndApplyDefaults(i),this.profiler=new z(this.options.logger),this.initializeCanvas(t)}catch(s){this.handleFailure(s)}}destroy(){this.canvas.remove()}get horizontalGenerator(){if(!this.internalHorizontalGenerator){let e=new x(this.src,{rotate:!1,profiler:this.profiler}),t=this.mask?new x(this.mask,{rotate:!1}):void 0;this.internalHorizontalGenerator=this.createGenerator({imageLoader:e,maskLoader:t})}return this.internalHorizontalGenerator}get verticalGenerator(){if(!this.internalVerticalGenerator){let e=new x(this.src,{rotate:!0,profiler:this.profiler}),t=this.mask?new x(this.mask,{rotate:!0}):void 0;this.internalVerticalGenerator=this.createGenerator({imageLoader:e,maskLoader:t})}return this.internalVerticalGenerator}determineCurrentGenerator(){return this.isVertical?this.verticalGenerator:this.horizontalGenerator}createGenerator(e){let t={...this.options,imageLoader:e.imageLoader,maskLoader:e.maskLoader};return ee(t)}validateAndApplyDefaults(e){let{getBoolean:t,getConstrainedNumber:r,getEnumValue:n}=te(e);return{...e,carvingPriority:r("carvingPriority",1),maxCarveUpSeamPercentage:r("maxCarveUpSeamPercentage",.6),maxCarveUpScale:r("maxCarveUpScale",10,1,10),maxCarveDownScale:r("maxCarveDownScale",1),scalingAxis:n("scalingAxis",S,S.Horizontal),logger:e.logger??(()=>{}),showEnergyMap:t("showEnergyMap",!1),demoMode:t("demoMode",!1)}}calculateDimensions(e){let{width:t,height:r}=this.options;if(t===void 0||r===void 0){let n=e.getBoundingClientRect();t=t??n.width,r=r??n.height}return{width:t,height:r}}initializeCanvas(e){let{width:t,height:r}=this.calculateDimensions(e);this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d"),this.canvas.width=this.width=t,this.canvas.height=this.height=r,this.canvas.style.display="block",e.appendChild(this.canvas),this.queueRedraw()}setSize(e,t){this.width=e,this.height=t,this.queueRedraw()}setWidth(e){this.width=e,this.queueRedraw()}setHeight(e){this.height=e,this.queueRedraw()}_setOptions(e){let t=this.options.showEnergyMap;this.options=this.validateAndApplyDefaults({...this.options,...e}),this.options.showEnergyMap!==t&&(this.cachedEnergyMapImageData=null),this.queueRedraw()}queueRedraw(){this.redrawQueued||(this.redrawQueued=!0,Promise.resolve().then(async()=>{await this.redraw(),this.redrawQueued=!1}))}determineCarvingParameters(e){let{carvingPriority:t,maxCarveUpSeamPercentage:r,maxCarveUpScale:n,maxCarveDownScale:i}=this.options,{width:s,height:a}=e,{isVertical:c,width:o,height:h}=this,m=c?h:o,y=c?o:h,g=m/y,p=Math.round(a*g),l=s-p;if(l===0)return{availableSeams:0,interpolationPixels:0,carveDown:!1};let u=Math.abs(l)*t,b=l>0?i:r,f=s*b,D=l>0?1:-1,w=l>0,v=Math.floor(Math.min(u,f))*D;if(w)return{availableSeams:v,interpolationPixels:0,carveDown:w};{let O=Math.round(a/y*m)-s,P=Math.floor(s*n)-s,W=Math.max(0,Math.min(O,P));return{availableSeams:-v,interpolationPixels:W,carveDown:w}}}async determineOrientation(){if(this.options.scalingAxis===S.Horizontal)return!1;if(this.options.scalingAxis===S.Vertical)return!0;let{width:e,height:t}=await this.horizontalGenerator.getImage(),r=e/t;return this.width/this.height>r}async refreshCachedArgs(){this.isVertical=await this.determineOrientation(),this.currentGenerator=this.determineCurrentGenerator()}async getEnergyMapImageData(){if(this.cachedEnergyMapImageData)return this.cachedEnergyMapImageData;let e=await this.currentGenerator.getImageData(),t=new C({imageData:e});return this.cachedEnergyMapImageData=t.getEnergyMapAsImageData(),this.cachedEnergyMapImageData}async getSourceImageData(){return this.options.showEnergyMap?await this.getEnergyMapImageData():await this.currentGenerator.getImageData()}async _redraw(){if(!this.width||!this.height)return;this.profiler.start("redraw"),await this.refreshCachedArgs();let e=await this.getSourceImageData(),{availableSeams:t,interpolationPixels:r,carveDown:n}=this.determineCarvingParameters(e),i;if(t===0)i=e;else{this.profiler.start("generateSeamGrid",1);let h=await this.currentGenerator.generateSeamGrid(Math.abs(t));this.profiler.end("generateSeamGrid"),n?i=this.filterPixels(e,h,t):i=this.interpolatePixels(e,h,t,r)}this.canvas.width=i.width,this.canvas.height=i.height,this.ctx.putImageData(i,0,0);let s=this.canvas.style,{isVertical:a,width:c,height:o}=this;s.transformOrigin="0 0",s.transform=a?"rotate(-90deg) translateX(-100%)":"",s.width=`${a?o:c}px`,s.height=`${a?c:o}px`,this.profiler.end("redraw")}interpolatePixels(e,t,r,n){let{width:i,height:s,data:a}=e,c=i+n,o=c*s*4,h=new Uint8ClampedArray(o),m=0,y=a.length/4,g=Math.floor(n/r),p=n%r,l=0;for(let u=0;u<y;u++){let b=t[u],f=u*4;if(b<r){let w=p>0&&b*p%r<p?g+1:g;if(l===0)for(let v=0;v<w;v++)h[m]=a[f],h[m+1]=a[f+1],h[m+2]=a[f+2],h[m+3]=a[f+3],m+=4;else{let v=(u-1)*4,N=a[v],O=a[v+1],$=a[v+2],P=a[v+3],Y=a[f]-N,W=a[f+1]-O,re=a[f+2]-$,ne=a[f+3]-P,ae=w+1;for(let V=0;V<w;V++){let G=(V+1)/ae;h[m]=Math.round(N+Y*G),h[m+1]=Math.round(O+W*G),h[m+2]=Math.round($+re*G),h[m+3]=Math.round(P+ne*G),m+=4}}}h[m]=a[f],h[m+1]=a[f+1],h[m+2]=a[f+2],h[m+3]=a[f+3],m+=4,++l===i&&(l=0)}return m!==o&&console.error(`[${M}] Mismatch during interpolation. Wrote ${m} bytes but expected ${o}.`),new ImageData(h,c,s)}filterPixels(e,t,r){let{width:n,height:i,data:s}=e,a=n-r,c=a*i*4,o=new Uint8ClampedArray(c),h=s.length/4,m=0;for(let y=0;y<h;y++)if(t[y]>=r){let p=y*4;o[m]=s[p],o[m+1]=s[p+1],o[m+2]=s[p+2],o[m+3]=s[p+3],m+=4}return m!==c&&console.error(`[${M}] Mismatch in pixel buffer size. Expected ${c}, but got ${m}.`),new ImageData(o,a,i)}handleFailure(e){if(this.hasFailed)return;this.hasFailed=!0,console.error(`[${M}] A critical error occurred. Falling back to <img>.`,e),this.canvas?.remove();let t=document.createElement("img");t.src=this.src,t.style.width="100%",t.style.height="100%",t.style.display="block",this.parentNode.appendChild(t)}};var j=class d extends HTMLElement{renderer=null;resizeObserver=null;intersectionObserver=null;updateQueue=new Set;isIntersecting=!1;storedDimensions=null;options={};static destructiveProperties=new Set(["src","scaling-axis","mask","generator"]);constructor(){super()}static get observedAttributes(){return["src","mask","on-screen-threshold",...["generator","carvingPriority","maxCarveUpSeamPercentage","maxCarveUpScale","maxCarveDownScale","scalingAxis","showEnergyMap","mask"].map(A)]}connectedCallback(){this.setupResizeObserver(),this.setupIntersectionObserver()}disconnectedCallback(){this.renderer?.destroy(),this.renderer=null,this.resizeObserver?.disconnect(),this.resizeObserver=null,this.intersectionObserver?.disconnect(),this.intersectionObserver=null}attributeChangedCallback(e,t,r){t!==r&&(this.updateQueue.size||setTimeout(this.processUpdates),this.updateQueue.add(e))}processUpdates=()=>{let e=Array.from(this.updateQueue);if(this.updateQueue.clear(),e.some(r=>d.destructiveProperties.has(r))){this.renderer?.destroy(),this.renderer=null,this.initializeRenderer();return}if(e.includes("on-screen-threshold")&&this.setupIntersectionObserver(),!this.renderer)return;let t=e.reduce((r,n)=>{if(n!=="src"&&n!=="on-screen-threshold"){let i=this.getAttribute(n);r[n]=i}return r},{});this.renderer.setOptions(t)};dispatchLogEvent=e=>{let t=new CustomEvent("log",{detail:{message:e},bubbles:!0,composed:!0});this.dispatchEvent(t)};initializeRenderer(){if(this.renderer)return;let e=this.getOptions();this.renderer=new B({parentNode:this,logger:this.dispatchLogEvent,...e})}calculateDimensions(){let e=this.clientWidth??100,t=this.clientHeight??100;return{width:e,height:t}}getOptions(){let e={};for(let t of d.observedAttributes){let r=A(t);if(this.hasAttribute(r)){let n=this.getAttribute(r);e[t]={"":!0,true:!0,false:!1}[n+""]??n}}return e}setupResizeObserver(){this.parentElement&&(this.resizeObserver=new ResizeObserver(()=>{let e=this.calculateDimensions();this.storedDimensions=e,this.attemptSetSize()}),this.resizeObserver.observe(this))}setupIntersectionObserver(){this.intersectionObserver?.disconnect();let e=this.getAttribute("on-screen-threshold")||"50px";this.intersectionObserver=new IntersectionObserver(t=>{for(let r of t)this.isIntersecting=r.isIntersecting,this.isIntersecting&&this.attemptSetSize()},{rootMargin:`${e} ${e} ${e} ${e}`}),this.intersectionObserver.observe(this)}attemptSetSize(){!this.isIntersecting||!this.storedDimensions||(this.renderer?.setSize(this.storedDimensions.width,this.storedDimensions.height),this.storedDimensions=null)}get maxCarveUpScale(){return this.options["max-carve-up-scale"]}set maxCarveUpScale(e){this.options["max-carve-up-scale"]=e,this.renderer?.setOptions({maxCarveUpScale:e})}get scalingAxis(){return this.options["scaling-axis"]}set scalingAxis(e){this.options["scaling-axis"]=e,this.renderer?.setOptions({scalingAxis:e})}get showEnergyMap(){return this.options["show-energy-map"]}set showEnergyMap(e){this.options["show-energy-map"]=e,this.renderer?.setOptions({showEnergyMap:e})}get onScreenThreshold(){let e=this.getAttribute("on-screen-threshold")||"50px";return parseInt(e.replace("px",""),10)}};customElements.define("fluid-img",j);export{j as FluidImg};
//# sourceMappingURL=fluid-img-demo.js.map
